---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by diyigeng.
--- 与服务时间同步的计时器 注意 必须获取过服务器时间后 计时才准确
--- DateTime: 2019/4/9 10:31
---
local SyncTimer = BaseClass("SyncTimer")
local TIME_RATE = 0.1 -- 检测时间频率
local MODE_STEP = 1 -- 步长计时模式
local MODE_END_TIME = 2 -- 截止时间模式
-- 构造函数
local function __init(self, mode, timeStamp, delay, one_shot, func, obj)


    -- 成员变量
    self.mode = nil -- 模式
    self.timeStamp = nil -- 时间戳
    -- 时长，毫秒级别
    self.delay = nil
    -- 回调函数
    self.target = {}
    self.target.func = nil -- 回调函数
    self.target.obj = nil -- 参数
    self.one_shot = false
    self.started = false
    self.over = false
    self.obj_not_nil =  false
    self:Init(mode, timeStamp, delay, one_shot, func, obj)
    -- weak表，保证定时器不影响目标对象的回收
    --self.target = setmetatable({}, {__mode = "v"})
    --if delay and func then
    --    self:Init(delay, func, obj, one_shot)
    --end
end

local function __delete(self)
    if  self.normalTimer ~= nil then
        self.normalTimer:Stop()
        self.normalTimer = nil
    end
    self.target = nil
end

--[[
    模式
    1 步长计时模式 开始时间戳 频率(毫秒) (one_shot)
    2 截止时间模式 结束时间戳 (单次)

    timeStamp 时间戳 1 模式  开始时间戳 2 模式 结束时间戳
    delay 1模式 延迟频率毫秒 2没用
    one_shot 1模式 true 触发一次  false 无线触发 2 只会触发一次
    func 回调函数
    obj 参数

]]
local function Init(self,mode, timeStamp, delay, one_shot, func, obj)
    self.mode = mode -- 模式
    self.timeStamp = timeStamp -- 时间戳
    -- 时长，毫秒级别
    self.delay = delay
    self.target.func = func -- 回调函数
    -- 回传对象，一般作为回调函数第一个self参数
    self.target.obj = obj -- 参数
    -- 是否是一次性计时
    self.one_shot = one_shot

    -- 是否已经启用
    self.started = false
    -- 是否已经结束
    self.over = false

    -- 传入对象是否为空
    self.obj_not_nil = obj and true or false
    --模拟update
    local simulationJavaMS = TimeSyncManager:GetInstance():GetSimulationJavaMS()
    if  self.normalTimer then
        self.normalTimer:Stop()
        self.normalTimer = nil
    end

    if self.mode == SyncTimer.MODE_STEP then
        local diffTime = simulationJavaMS - self.timeStamp
        if diffTime < 0  then
            diffTime = 0
        end
        -- 上次触发时间
        --Logger.LogVars("self.delay * math.floor(diffTime / self.delay ) : ", (self.delay * math.floor(diffTime / self.delay )))
        self.lastTriggerTimeStamp = self.timeStamp + self.delay * math.floor(diffTime / self.delay ) -- 经过了多少时间频率
        --Logger.LogVars(" SyncTimer Init .....lastTriggerTimeStamp ",self.lastTriggerTimeStamp)
        --self.normalTimer = TimerManager:GetInstance():GetTimer(TIME_RATE, Bind(self,self.__JustSimulateUpdate ), nil, false)
        self.normalTimer = TimerManager:GetInstance():GetTimer(TIME_RATE, self.__JustSimulateUpdate, self, false)
    else
        --Logger.LogVars(" SyncTimer Init .....",self.mode," simulationJavaMS    : ",simulationJavaMS)
        --self.normalTimer = TimerManager:GetInstance():GetTimer(TIME_RATE, Bind(self,self.__JustSimulateUpdate ), nil, false)
        self.normalTimer = TimerManager:GetInstance():GetTimer(TIME_RATE, self.__JustSimulateUpdate, self, false)
    end
end

--模拟update
local function __JustSimulateUpdate(self) -- 参数 update函数

    --if self == nil then
    --    Logger.LogError("self is nil return~",self)
    --    return
    --end
    --Logger.LogError("__JustSimulateUpdate~")
    local simulationJavaMS = TimeSyncManager:GetInstance():GetSimulationJavaMS()

    if self.mode == SyncTimer.MODE_STEP then
        --Logger.LogVars(" __JustSimulateUpdate 11 self.lastTriggerTimeStamp :",self.lastTriggerTimeStamp,"  self.delay :", self.delay)
        --Logger.LogVars(" __JustSimulateUpdate  222  zonggong :",(self.lastTriggerTimeStamp + self.delay),"  simulationJavaMS :", simulationJavaMS)
        --Logger.LogVars(" __JustSimulateUpdate  3333  jianqu :",(simulationJavaMS - self.lastTriggerTimeStamp - self.delay))



        if  simulationJavaMS >  self.lastTriggerTimeStamp + self.delay then
            self.lastTriggerTimeStamp = self.lastTriggerTimeStamp + self.delay

            -- 说明：运行在保护模式，有错误也只是停掉定时器，不要让客户端挂掉
            local status, err
            if self.obj_not_nil then
                status, err = pcall(self.target.func,self, self.target.obj)
            else
                status, err = pcall(self.target.func,self)
            end
            if not status then
                Logger.LogError(err)
            end
            --Logger.LogVars(" __JustSimulateUpdate  44444  触发时间 :",self.lastTriggerTimeStamp, " status : ",status, " err : ",err)
            if self.one_shot then -- 一次性触发
                self:Stop() -- 暂停触发行为
            else
            end
        end
    else -- 截止时间模式
        --Logger.LogVars(" __JustSimulateUpdate self.timeStamp .....",self.timeStamp," simulationJavaMS    : ",simulationJavaMS)
        if simulationJavaMS >= self.timeStamp  then
            local status, err
            if self.obj_not_nil then
                status, err = pcall(self.target.func,self, self.target.obj)
            else
                status, err = pcall(self.target.func,self)
            end
            if not status then
                Logger.LogError(err)
            end
            self:Stop() -- 暂停触发行为
        end
    end
end

-- 启动计时
local function Start(self)
    self.started = true
    self.normalTimer:Start()
end

-- 暂停计时
local function Pause(self)
    self.started = false
    self.normalTimer:Pause()
end

-- 恢复计时
local function Resume(self)
    self.started = true
    self.normalTimer:Resume()
end

-- 停止计时
local function Stop(self)
    --Logger.LogVars("SyncTimer,,,,,,,,,,,,,,,,,,,,,, Stop")
    self.normalTimer:Stop()
    self.one_shot = false
    self.target.func = nil
    self.target.obj = nil
    self.started = false
    self.over = true
end


-- 是否已经完成计时
local function IsOver(self)
    self.normalTimer:IsOver()
end

SyncTimer.__init = __init
SyncTimer.__delete = __delete

SyncTimer.__JustSimulateUpdate = __JustSimulateUpdate

SyncTimer.Init = Init
SyncTimer.Start = Start
SyncTimer.Pause = Pause
SyncTimer.Resume = Resume
SyncTimer.Stop = Stop
--SyncTimer.Reset = Reset
SyncTimer.IsOver = IsOver
SyncTimer.MODE_STEP = MODE_STEP
SyncTimer.MODE_END_TIME = MODE_END_TIME
return SyncTimer
