---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by aaa.
--- DateTime: 19/7/12 19:46
---场景加载工具类
---用于解析场景资源类,加载资源并调用组装方法

local SceneLoadManager = BaseClass("SceneLoadManager", Singleton)

-- 构造函数
local function __init(self)
    self.sceneDataCache = {}
end

local function GenSceneAssetFullPath(name)
    return "Art/Scenes/scene_".. name .."/scene_".. name .."/".. name .."_sceneData.asset"
end

local function CoGenerateScene(self,path,progress_callback,addition)

    if addition == nil then
        addition = false
    end

    local loadingStep = 0
    local loadingProgress = 0
    local function ProgressCallback(co, progress)

        if progress_callback ~= nil then
            progress_callback(co,loadingProgress + progress * loadingStep)
        end
        return coroutine.yieldcallback(co,  progress )
    end
    loadingStep = 0.05
    loadingProgress = 0
    local asset = nil
    local assetSet = nil
    local cache = self.sceneDataCache[path]

    if cache ~= nil
            and (not IsNull(cache.asset))
            and (not IsNull(cache.set))
    then
        local sceneIndex = CS.SceneDataUtilities.GetSceneIndex(cache.asset.name)
        if sceneIndex >= 0 then
            --Logger.Log("检查是否重复加载场景?" .. path)
            return
        else
            asset = cache.asset
            assetSet = cache.set
        end
    end

    if asset == nil then
        asset = ResourcesManager:GetInstance():CoLoadAsync(path, typeof(CS.SceneDataLitAsset), ProgressCallback)
    end
    if assetSet == nil then
        assetSet = CS.SceneAssetSet()
    end


    if cache == nil then
        cache = {}
        self.sceneDataCache[path] = cache
    end
    cache.asset = asset
    cache.set = assetSet

    CS.SceneDataUtilities.StartLoading(not addition)

    --load node
    loadingProgress = 0.05
    loadingStep = 0.45
    assetSet.sceneRoot = ResourcesManager:GetInstance():CoLoadAsync(asset.sceneRoot, typeof(CS.UnityEngine.GameObject), ProgressCallback)
    if QualityManager:GetInstance():SceneEffectEnabled() then
        loadingProgress = 0.5
        loadingStep = 0.1
        assetSet.sceneFxRoot = ResourcesManager:GetInstance():CoLoadAsync(asset.sceneFxRoot, typeof(CS.UnityEngine.GameObject), ProgressCallback)
        loadingProgress = 0.6
        loadingStep = 0.1
        assetSet.camFxRoot = ResourcesManager:GetInstance():CoLoadAsync(asset.camFxRoot, typeof(CS.UnityEngine.GameObject), ProgressCallback)
    end
    loadingProgress = 0.7
    loadingStep = 0
    --load lightMapData

    if not IsNull( asset.lightMapData ) then
        local lmCount = asset.lightMapData.Length
        assetSet.lightMapData = CS.System.Array.CreateInstance(typeof(CS.SceneDataAsset.LightMapDataToken), lmCount);
        for i = 0, lmCount-1 do
            local v = asset.lightMapData[i]
            local dataToken = CS.SceneDataAsset.LightMapDataToken()

            if not string.isNilOrEmpty(v.light) then
                dataToken.light
                = ResourcesManager:GetInstance():CoLoadAsync(
                        v.light
                        , typeof(CS.UnityEngine.Texture2D)
                        , ProgressCallback
                )
            end

            if QualityManager:GetInstance():DirLMEnabled() then
                if not string.isNilOrEmpty(v.dir) then
                    dataToken.dir
                    = ResourcesManager:GetInstance():CoLoadAsync(
                            v.dir
                            , typeof(CS.UnityEngine.Texture2D)
                            , ProgressCallback
                    )
                end

                if not string.isNilOrEmpty(v.shadow) then
                    dataToken.shadow
                    = ResourcesManager:GetInstance():CoLoadAsync(
                            v.shadow
                            , typeof(CS.UnityEngine.Texture2D)
                            , ProgressCallback
                    )
                end
            end
            assetSet.lightMapData[i] = dataToken
            loadingProgress = 0.7 + (0.25/lmCount)*(i+1)
        end
    end
    loadingProgress = 0.95

    --load reflectInfos
    if not IsNull(asset.reflectInfos )then
        local reflCount = asset.reflectInfos.Length
        assetSet.reflectInfos = CS.System.Array.CreateInstance(typeof(CS.SceneDataAsset.ReflectInfo), reflCount);
        for i = 0, reflCount-1 do
            local info = CS.SceneDataAsset.ReflectInfo()
            local v = asset.reflectInfos[i]
            info.name = v.name
            info.refTex = ResourcesManager:GetInstance():CoLoadAsync(v.refTex, typeof(CS.UnityEngine.Texture), ProgressCallback)
            assetSet.reflectInfos[i] = info
        end
    end
    loadingProgress = 0.95
    --load sky
    if not string.isNilOrEmpty( asset.skyMat )  then
        assetSet.skyMat = ResourcesManager:GetInstance():CoLoadAsync(asset.skyMat, typeof(CS.UnityEngine.Material), ProgressCallback)
    end
    loadingProgress = 1
    --load light probes data
    if not string.isNilOrEmpty( asset.lpData ) then
        assetSet.lpData = ResourcesManager:GetInstance():CoLoadAsync(asset.lpData, typeof(CS.UnityEngine.LightProbes), ProgressCallback)
    end

    CS.SceneDataUtilities.GeneratScene(asset,assetSet,addition)
    -- coroutine.waitwhile(function ()
    --     return	v1:MoveNext()
    -- end)
    CS.SceneDataUtilities.EndLoading()
    if not addition then
        if string.contains(asset.name,"_empty_") then
            CS.SceneDataUtilities.ConfigMainCamera(false)
        else
            CS.SceneDataUtilities.ConfigMainCamera(true)
            QualityManager:GetInstance():UpdateXFramParam()
        end

        --if QualityManager:GetInstance():GetLOD() > 400 then
        --    CS.SceneDataUtilities.SettingXFrameParam(1)
        --else
        --    CS.SceneDataUtilities.SettingXFrameParam(0.6666)
        --end

    end

end

---default value:
---pos = Vector3.zero
---rotate = Vector3.zero
---hasShadow = true
local function ConfigLitAndShadow(self, path, pos, rotate, hasShadow,size)

    if pos == nil then
        pos = Vector3.zero
    end
    if rotate == nil then
        rotate = Vector3.zero
    end
    if hasShadow == nil then
        hasShadow = true
    end
    if size == nil then
        size = 15
    end
    if
        not string.isNilOrEmpty(path)
        and self.sceneDataCache ~= nil
    then
        local cache = self.sceneDataCache[path]
        if cache ~= nil and (not IsNull(cache.asset)) then
            local enableShadow = hasShadow and QualityManager:GetInstance():ShadowEnabled();

            CS.SceneDataUtilities.ConfigLitAndShadow(cache.asset,cache.set,pos,rotate,enableShadow,size)
        else
            CS.SceneDataUtilities.SetupSceneNode("empty")
        end
    end
end

local function UnloadAssetAssetBundle(asset)
    CS.SceneDataUtilities.CleanSceneNode(asset)
    --unload assetbundle
    if not string.isNilOrEmpty(asset.sceneRoot) then
        ResourcesManager:GetInstance():UnloadAssetBundle(asset.sceneRoot)
    end
    if QualityManager:GetInstance():SceneEffectEnabled() then
        if not string.isNilOrEmpty(asset.sceneFxRoot) then
            ResourcesManager:GetInstance():UnloadAssetBundle(asset.sceneFxRoot)
        end
        if not string.isNilOrEmpty(asset.camFxRoot) then
            ResourcesManager:GetInstance():UnloadAssetBundle(asset.camFxRoot)
        end
    end

    if not IsNull( asset.lightMapData ) then
        local lmCount = asset.lightMapData.Length
        for i = 0, lmCount-1 do
            local v = asset.lightMapData[i]

            if not string.isNilOrEmpty(v.light) then
                ResourcesManager:GetInstance():UnloadAssetBundle(v.light)
            end
            if QualityManager:GetInstance():DirLMEnabled() then
                if not string.isNilOrEmpty(v.dir) then
                    ResourcesManager:GetInstance():UnloadAssetBundle(v.dir)
                end
                if not string.isNilOrEmpty(v.shadow) then
                    ResourcesManager:GetInstance():UnloadAssetBundle(v.shadow)
                end

            end
        end
    end
    --load reflectInfos
    if not IsNull(asset.reflectInfos )then
        local reflCount = asset.reflectInfos.Length
        for i = 0, reflCount-1 do
            if not string.isNilOrEmpty(asset.reflectInfos[i].refTex) then
                ResourcesManager:GetInstance():UnloadAssetBundle(asset.reflectInfos[i].refTex)
            end
        end
    end

    --load sky
    if not string.isNilOrEmpty( asset.skyMat )  then
        ResourcesManager:GetInstance():UnloadAssetBundle(asset.skyMat)
    end
    --load light probes data
    if not string.isNilOrEmpty( asset.lpData ) then
        ResourcesManager:GetInstance():UnloadAssetBundle(asset.lpData)
    end
end

local function CleanSceneNode(self,path)
    if
        string.isNilOrEmpty(path)
        or self.sceneDataCache == nil
    then
        return;
    end
    local cache = self.sceneDataCache[path]
    if cache ~= nil and (not IsNull( cache.asset ) )then
        local asset = cache.asset
        UnloadAssetAssetBundle(asset)
        ResourcesManager:GetInstance():UnloadAssetBundle(path)
    end

    self.sceneDataCache[path] = nil

end

local function CleanAllSceneNode(self)
    if self.sceneDataCache == nil or table.count(self.sceneDataCache )< 1 then
        return
    end

    for k, v in pairs(self.sceneDataCache) do
        if v ~= nil and (not IsNull(v.asset)) then
            UnloadAssetAssetBundle(v.asset)
            ResourcesManager:GetInstance():UnloadAssetBundle(k)
        end
    end
    self.sceneDataCache = {}
end

local function FindSceneRoot(self,path)

    if
        not string.isNilOrEmpty(path)
        and self.sceneDataCache ~= nil
    then
        local cache = self.sceneDataCache[path]
        if cache ~= nil and (not IsNull(cache.asset)) then
            return CS.SceneDataUtilities.FindSceneRoot(cache.asset);
        end
    end
    return nil
end

local function  ConfigBattleCam(self, vCam, pos, angle, fov, focusPos )
    CS.SceneDataUtilities.ConfigBattleCam(vCam,pos,angle,fov,focusPos)
end

local function TriggerBlockCompont(self)
    CS.SceneDataUtilities.TriggerBlockCompont()
end

local function GetSceneIndex(self,path)
    if
        not string.isNilOrEmpty(path)
        and self.sceneDataCache ~= nil
    then
        local cache = self.sceneDataCache[path]
        if cache ~= nil and (not IsNull(cache.asset )) then
            return CS.SceneDataUtilities.GetSceneIndex(cache.asset.name);
        end
    end
    return -1
end
local function GetScenePosOffset(self,path)
    if
    not string.isNilOrEmpty(path)
            and self.sceneDataCache ~= nil
    then
        local cache = self.sceneDataCache[path]
        if cache ~= nil and (not IsNull(cache.asset )) then
            local SceneName=string.gsub(cache.asset.name,"_sceneData","")
            return CS.SceneDataUtilities.GetScenePosOffset(SceneName);
        end
    end
    return Vector3.zero
end

local function ConfigCameraStyle(self,style)
    CS.SceneDataUtilities.ConfigCameraStyle(style)
end

local function setMainCameraPos()
    CS.SceneDataUtilities.setMainCameraPos()
end


local function OpenOneScene(self,sceneName)
    Logger.Log("sceneName  "..sceneName)
    local scenePath= GenSceneAssetFullPath(sceneName);

    local posOffset = GetScenePosOffset(scenePath);
    ConfigLitAndShadow(self,scenePath,posOffset,Vector3.zero)

    UIManager:GetInstance():CloseWindow(UIWindowNames.UIStoryJump)
    setMainCameraPos()

end



local function CoSwitchScenePreload(self,tarPath,srcPath)

    local asset = nil
    local assetSet = nil
    local cache = self.sceneDataCache[tarPath]

    if cache == nil then
        return
    end

    local srcCache = self.sceneDataCache[srcPath]

    if srcCache ~= nil
            and (not IsNull(srcCache.asset))
            and (not IsNull(srcCache.set))
    then
        asset = srcCache.asset
        assetSet = srcCache.set
    end

    if asset == nil then
        asset = ResourcesManager:GetInstance():CoLoadAsync(srcPath, typeof(CS.SceneDataLitAsset), nil)
    end
    if assetSet == nil then
        assetSet = CS.SceneAssetSet()
    end


    if srcCache == nil then
        srcCache = {}
        self.sceneDataCache[srcPath] = srcCache
    end

    srcCache.asset = asset
    srcCache.set = assetSet

    --load node

    assetSet.sceneRoot = ResourcesManager:GetInstance():CoLoadAsync(asset.sceneRoot, typeof(CS.UnityEngine.GameObject), nil)
    if QualityManager:GetInstance():SceneEffectEnabled() then
        assetSet.sceneFxRoot = ResourcesManager:GetInstance():CoLoadAsync(asset.sceneFxRoot, typeof(CS.UnityEngine.GameObject), ProgressCallback)
        assetSet.camFxRoot = ResourcesManager:GetInstance():CoLoadAsync(asset.camFxRoot, typeof(CS.UnityEngine.GameObject), ProgressCallback)
    end
    --load lightMapData

    if not IsNull( asset.lightMapData ) then
        local lmCount = asset.lightMapData.Length
        assetSet.lightMapData = CS.System.Array.CreateInstance(typeof(CS.SceneDataAsset.LightMapDataToken), lmCount);
        for i = 0, lmCount-1 do
            local v = asset.lightMapData[i]
            local dataToken = CS.SceneDataAsset.LightMapDataToken()

            if not string.isNilOrEmpty(v.light) then
                dataToken.light
                = ResourcesManager:GetInstance():CoLoadAsync(
                        v.light
                , typeof(CS.UnityEngine.Texture2D)
                , nil
                )
            end

            if QualityManager:GetInstance():DirLMEnabled() then
                if not string.isNilOrEmpty(v.dir) then
                    dataToken.dir
                    = ResourcesManager:GetInstance():CoLoadAsync(
                            v.dir
                    , typeof(CS.UnityEngine.Texture2D)
                    , nil
                    )
                end

                if not string.isNilOrEmpty(v.shadow) then
                    dataToken.shadow
                    = ResourcesManager:GetInstance():CoLoadAsync(
                            v.shadow
                    , typeof(CS.UnityEngine.Texture2D)
                    , nil
                    )
                end
            end
            assetSet.lightMapData[i] = dataToken

        end
    end

    --load reflectInfos
    if not IsNull(asset.reflectInfos )then
        local reflCount = asset.reflectInfos.Length
        assetSet.reflectInfos = CS.System.Array.CreateInstance(typeof(CS.SceneDataAsset.ReflectInfo), reflCount);
        for i = 0, reflCount-1 do
            local info = CS.SceneDataAsset.ReflectInfo()
            local v = asset.reflectInfos[i]
            info.name = v.name
            info.refTex = ResourcesManager:GetInstance():CoLoadAsync(v.refTex, typeof(CS.UnityEngine.Texture), nil)
            assetSet.reflectInfos[i] = info
        end
    end

    --load sky
    if not string.isNilOrEmpty( asset.skyMat )  then
        assetSet.skyMat = ResourcesManager:GetInstance():CoLoadAsync(asset.skyMat, typeof(CS.UnityEngine.Material), nil)
    end
    loadingProgress = 1
    --load light probes data
    if not string.isNilOrEmpty( asset.lpData ) then
        assetSet.lpData = ResourcesManager:GetInstance():CoLoadAsync(asset.lpData, typeof(CS.UnityEngine.LightProbes), nil)
    end
end

local function SwitchScene(self,tarPath,srcPath)

    local asset = nil
    local assetSet = nil
    local cache = self.sceneDataCache[tarPath]

    if cache == nil then
        return
    end

    local srcCache = self.sceneDataCache[srcPath]

    if srcCache ~= nil
            and (not IsNull(srcCache.asset))
            and (not IsNull(srcCache.set))
    then
        asset = srcCache.asset
        assetSet = srcCache.set
    end

    CS.SceneDataUtilities.SwitchSceneLit(cache.asset,asset,assetSet)
end

SceneLoadManager.__init = __init
SceneLoadManager.CoGenerateScene = CoGenerateScene
SceneLoadManager.ConfigLitAndShadow = ConfigLitAndShadow
SceneLoadManager.CleanSceneNode = CleanSceneNode
SceneLoadManager.CleanAllSceneNode =CleanAllSceneNode
SceneLoadManager.ConfigBattleCam = ConfigBattleCam
SceneLoadManager.TriggerBlockCompont = TriggerBlockCompont
SceneLoadManager.GetSceneIndex = GetSceneIndex
SceneLoadManager.FindSceneRoot =FindSceneRoot
SceneLoadManager.GetScenePosOffset =GetScenePosOffset
SceneLoadManager.GenSceneAssetFullPath = GenSceneAssetFullPath
SceneLoadManager.ConfigCameraStyle = ConfigCameraStyle
SceneLoadManager.OpenOneScene = OpenOneScene
SceneLoadManager.setMainCameraPos = setMainCameraPos
SceneLoadManager.CoSwitchScenePreload = CoSwitchScenePreload
SceneLoadManager.SwitchScene = SwitchScene
return SceneLoadManager;
