---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ZYC.
--- DateTime: 2019/6/10
---

local BattleRoleViewManager=require "GameLogic.BattleNew.View.Manager.BattleRoleViewManager"
local BattlePositionManager=require "GameLogic.BattleNew.View.Manager.BattlePositionManager"
local BattleCameraManager=require"GameLogic.BattleNew.View.Manager.BattleCameraManager"
local BattleViewContext=BaseClass("BattleViewContext")

local function __init(self)
    --角色管理
    self.battleRoleViewManager = nil
    --战场站位管理
    self.battlePositionManager = nil
    --相机管理
    self.battleCameraManager = nil
    --事件通信
    self.battleMessage = nil
    --击杀相机
    self.KillCamGo = nil
    --逻辑类
    self.oneBattle = nil
    --所以行爲
    self.actions = nil
    --切换时封锁技能行为
    self.blockActionNum = 0
    --当前攻击的单位
    self.curActor = nil
    --当前时间缩放比例
    self.timeScale = 1
    --当前时间缩放值
    self.timeScaleVal = 1
    self.isDestory = false
    --是否是己方先手
    self.isSelfFirst = true
end

--击杀相机的所有预设加载路径
BattleViewContext.KillCamPath = {
    "Art/Roles/common/KillCam_0.prefab",
    "Art/Roles/common/KillCam_1.prefab",
    "Art/Roles/common/KillCam_2.prefab"
}
--击杀相机
BattleViewContext.KillCam = {}

--先获相机的位置
local function GetKillCamGo(self, index)
    --如果当前相机为空，那么就从加载路径中加载一个出来
    if IsNull(BattleViewContext.KillCam[index]) then
        BattleViewContext.KillCam[index] = GameObjectPool:GetInstance():CoGetGameObjectAsync(BattleViewContext.KillCamPath[index])
        --将相机设置为非激活的状态
        if not IsNull(self.KillCamGo) then
            self.KillCamGo:SetActive(false)
        end
    end
    return BattleViewContext.KillCam[index]
end

--触发击杀相机
local function TriggerKillCam(self, roleView)
    local index = roleView.position + 1
    local camGo = BattleViewContext.KillCam[index]
    if not IsNull(camGo) then
        camGo:SetActive(true)
        --TODO:以下内容
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.BindingCameraBrain(camGo, self.battleCameraManager.camera.gameObject)
        local pD = camGo:GetComponentInChildren(typeof(CS.UnityEngine.Playables.PlayableDirector))
        if not IsNull(pD) then
            pD:Play()
        end
    end
end

--设置击杀相机
local function SetKillCam(self,target)
    local KillCamGo=GetKillCamGo(self,target.entity.position+1)
    if not IsNull(KillCamGo) then
        --将相机设置父对象并设置非激活，并将位置和旋转归零，完全跟随父对象
        KillCamGo.transform:SetParent(target.transform,false)
        KillCamGo.transform.localPosition=Vector3.zero
        KillCamGo.transform.localEulerAngles=Vector3.zero
    end
end




--游戏开始相机贴近玩家
local function PveActionCloserRole(self,func)
    self.battleCameraManager:PveActionCloserRole(func)
end

--游戏回合的切换
local function PveRoundSwitch(self,type)
    --相机位置发生相应的改变
    if type==1 then
        self.battleCameraManager:CoverInit()
    end
    --TODO:
    --self.battleRoleViewManager:OnRolesReset()
end

--添加一波角色
local function AddWaveRoles(self,roles)
    coroutine.start(function()
        for i, v in ipairs(roles) do
            if v. hp > 0 then
                self.battleRoleViewManager:OnCreateView(v,true)
            end
        end
        self.oneBattle:BeginBattle()
    end)
end

--是否封锁技能行为
local function BlockAction(self,isBlock)
    if isBlock then
        self.blockActionNum =  self.blockActionNum + 1
    else
        self.blockActionNum = self.blockActionNum - 1
    end
end

local function PlaySkillEffects(self,data)
    if data ~= nil and #data > 0 then
        for i, v in ipairs(data) do
            local actRole =  self.battleRoleViewManager:GetRoleViewById(v.teamId,v.entityId)
            actRole:SimpleHandleSkil(v)
        end
    end
    --检测角色死亡
    self.battleRoleViewManager:CheckRoleDead()
end

--改变时间缩放
local function ChangeTimeScale(self,_timeScale)
    self.timeScaleVal = _timeScale
    Time.timeScale = self.timeScaleVal * self.timeScale
end
--设置时间缩放率
local function SetTimeScale(self,_val)
    self.timeScale = _val
    Time.timeScale = self.timeScaleVal * self.timeScale
end
--重置时间缩放
local function ResetTimeScale(self)
    self.timeScale = 1
    self.timeScaleVal = 1
    Time.timeScale = 1
end

local function BattleEndCheck(self)
    --如果已经是结束
    if self.battle_end_check then
        return
    end
    self.battle_end_check = true
    if self.oneBattle.isEnd then
        self.oneBattle:CoTryTriggerStory(2, nil,function()
            --self.battleMessage:Broadcast(BattleEnum.BattleMessage.BATTLE_FINISH, self.settlement)
            ResetTimeScale(self)
            if self.settlement.isSuccess then
                self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUIRESULTBEGIN)
                UIManager:GetInstance():Broadcast(UIMessageNames.UIBATTLE_WIN__CAM,0)
                self.battleRoleViewManager:WinDestroyRole()
            else
                self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUIRESULT,self.settlement)
            end
        end)
    else
        coroutine.start(function()
            coroutine.waituntil(function()
                return self.blockActionNum <= 0
            end)
            if self.isDestory then
                return
            end
            --pvp 回合数可能不相同  pve不受影响
            if self.round == self.oneBattle.round then
                ChangeTimeScale(self,1)
                self.oneBattle:ChangeRoundState(BattleEnum.BattleRoundState.ROUNDEND)
            end
        end)
    end

end

local function SinglePlayAction(self)
    --如果已经销毁
    if self.isDestory then
        return
    end
    self.curActor = nil
    if #self.actions > 0 then
        coroutine.start(function()
            coroutine.waituntil(function()
                return self.blockActionNum <= 0
            end)
            if #self.actions <= 0 then
                SinglePlayAction(self)
            end
            local action = self.actions[1]
            table.remove(self.actions,1)
            if action ~= nil then
                --查找角色 使用技能或者召喚
                self.curActor =  self.battleRoleViewManager:GetRoleViewById(action.teamId,action.entityId)
                coroutine.waituntil(function()
                    return self.curActor.currentState ~= BattleEnum.BattleRoleState.USE_SKILL
                end)
                --如果已经结束
                if self.isDestory then
                    return
                end
                if action.useEffect then
                    self.curActor:PlayChooseSkillEffect()
                end
                if action.type == 1 then
                    self.curActor:UseSkill(action.skillId,action.doubleHit,action.cases,action.isGuaidSkill,
                            #self.actions == 0 and self.oneBattle.isEnd,action.returnState,action.intervener,self.oneBattle.simpleThreeBeat)
                else
                    --首先要创建一个角色
                    self.battleRoleViewManager:OnCreateView(action.call.data,false)
                    self.curActor:CallGuardian(action.call,self.oneBattle.simpleThreeBeat,action.effectTargets)
                    self.curActionEffectTargets = action.effectTargets
                end
            else
                Logger.LogError("技能行为为空")
                SinglePlayAction(self)
            end
        end)
    else
        self.battle_end_check = false
        PlaySkillEffects(self,self.endAction)
        self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYCRYFLY, true)
        --BattleEndCheck(self)
    end
end
--召唤出场技能效果触发
local function PlayCallOverEffect(self)
    if self.curActionEffectTargets ~= nil and #self.curActionEffectTargets > 0 then
        for i, v in ipairs(self.curActionEffectTargets) do
            local actRole =  self.battleRoleViewManager:GetRoleViewById(v.teamId,v.entityId)
            actRole:SimpleHandleSkil(v)
        end
        self.battleRoleViewManager:CheckRoleDead()
        self.curActionEffectTargets = nil
    end
end
--ji能使用完毕
local function SomeoneSkillOver(self)
    self.battleRoleViewManager:ResetBattleRole()
    PlayCallOverEffect(self)
    SinglePlayAction(self)

    if self.saveRoleView ~= nil then
        self.saveRoleView:ChangeBattlePosition(BattleEnum.BattlePosition.FRONT)
        self.saveRoleView:ChangeParent()
        self.saveRoleView:ChangeState(BattleEnum.BattleRoleState.CHANGEPOSITION)
        self.saveRoleView = nil
    end
end
--召唤的时候  召唤物意外死亡
local function CallGuardDead(self,saveView)
    self.saveRoleView = saveView
end

local function SequencePlay(self,data,endData,isMine,settlement,round)
    self.actions = data
    self.endAction = endData
    self.settlement = settlement
    --隐藏UI
    self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUIHIDETYPE, 2)
    --回合提示
    if not isMine then
        self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYPAUSE,2)
    else
        self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYPAUSE,1)
    end
    --每两回合重置一次
    self.round = round
    if (self.isSelfFirst and self.round%2 == 1) or (not self.isSelfFirst and self.round%2 == 0) then
        self.play_came_anim = false
    end
    if #data > 0 and not self.play_came_anim then
        --遍历决定策略
        --在此判断出执行方案
        for i = 1,#data do
            if i < #data then
                if data[i].type == 1 then
                    --如果连着两个都是技能
                    if data[i+1].type == 1 then
                        --如果攻击单位不同
                        if data[i].teamId == data[i+1].teamId and data[i].entityId == data[i+1].entityId then
                            data[i].returnState = 2
                        else
                            data[i].returnState = 1
                        end
                    else
                        data[i].returnState = 0
                    end
                end
            else
                if data[i].type == 1 then
                    data[i].returnState = 0
                end
            end
            --判断释放播放技能提示特效
            if i > 1 then
                if data[i].teamId == data[i-1].teamId and data[i].entityId == data[i-1].entityId then
                    data[i].useEffect = false
                else
                    data[i].useEffect = true
                end
            else
                data[i].useEffect = true
            end
        end

        if data[1].type == 0 or data[1].isGuaidSkill then
            self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYClOSERBEGIN,Bind(self,SinglePlayAction))
        else
            self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYClOSERBEGIN)
            SinglePlayAction(self)
        end
        self.play_came_anim = true
    else
        SinglePlayAction(self)
    end

end

--强制停止播放行动
local function ForceStopAction(self,downCount,round)
    --停止当前播放的timeline
    if self.curActor ~= nil then
        self.curActor:ForceEndSkill()
    end
    self.actions = {}
    --重置场中角色
    local logicRoles = self.oneBattle.battlePlayerManager:GetAllBattleRoles()
    local viewRoles = self.battleRoleViewManager.roles

    --查找相同的
    for i = #viewRoles, 1,-1 do
        local v = viewRoles[i]
        local count = table.removebyvalue(logicRoles,v.entity)
        --没有移除  如果血量>0  移动到后排
        if count == 0 then
            if v.entity.hp > 0 then
                if not v.entity:CheckIsMainRole() then
                    v:OnDestroy()
                else
                    v:ChangeBattlePosition(BattleEnum.BattlePosition.BACK)
                    v:ChangeParent()
                end
            else
                v:ForceDead()
            end
        else
            if v.entity.hp <= 0 then
                v:ForceDead()
            else
                --如果是在后方  移动到前方
                if v.battlePosition == BattleEnum.BattlePosition.BACK then
                    v:ChangeBattlePosition(BattleEnum.BattlePosition.FRONT)
                    v:ChangeParent()
                end
            end
        end
    end
    --如果列表里面还有角色  生成
    coroutine.start(function()
        self.blockActionNum =  self.blockActionNum + 1
        for i, v in pairs(logicRoles) do
            if v.hp > 0 then
                self.battleRoleViewManager:OnCreateView(v,true)
            end
        end
        self.blockActionNum =  self.blockActionNum - 1
    end)
    --判断当前回合是哪一方
    if round ~= nil and self.oneBattle.currentRoundState == BattleEnum.BattleRoundState.ROUNDFRONT then
        local temp = round%2
        if self.oneBattle.battlePlayerManager.isFirst then
            if temp == 1 then
                self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYROUNDDATATOUI, 1,nil,nil,downCount)
            else
                self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYROUNDDATATOUI, 2,nil,nil,downCount)
            end
        else
            if temp == 0 then
                self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYROUNDDATATOUI, 1,nil,nil,downCount)
            else
                self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYROUNDDATATOUI, 2,nil,nil,downCount)
            end
        end
    end

end
--结算后播放剧情 删除人物
local function OnPlayStory(self)
    self.battleRoleViewManager:OnDestroy()
end

--设置敌方先手
local function SetEnemyFirst(self)
    self.isSelfFirst = false
end

--添加事件监听
local function AddEventListener(self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.NOTIFYPLAYSKILLEFFECT,PlaySkillEffects,self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.PVE_ACTION_PLAY,SequencePlay,self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.NOTIFYClOSERBEGIN,PveActionCloserRole,self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.NOTIFYROUNDDATATOUI,PveRoundSwitch,self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.ADD_WAVE_ROLES,AddWaveRoles,self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.FORCE_STOP_ACTION,ForceStopAction,self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.SET_TIME_SCALE_MULT,SetTimeScale,self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.NOTIFYSPLAYSTORY,OnPlayStory , self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.NOTIFYENEMYFIRST,SetEnemyFirst,self)
end
--移除事件监听
local function RemoveEventListener(self)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.NOTIFYPLAYSKILLEFFECT,PlaySkillEffects)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.PVE_ACTION_PLAY,SequencePlay)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.NOTIFYClOSERBEGIN,PveActionCloserRole)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.NOTIFYROUNDDATATOUI,PveRoundSwitch)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.ADD_WAVE_ROLES,AddWaveRoles)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.FORCE_STOP_ACTION,ForceStopAction)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.SET_TIME_SCALE_MULT,SetTimeScale)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.NOTIFYSPLAYSTORY,OnPlayStory )
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.NOTIFYENEMYFIRST,SetEnemyFirst)
end

local function OnInit(self,battleMessage,oneBattle,scene_mask_col,cam_trans,battleCache)
    self.battleMessage=battleMessage
    self.oneBattle=oneBattle
    self.battleRoleViewManager=BattleRoleViewManager.New()
    self.battleRoleViewManager:OnInit(self)
    self.battlePositionManager=BattlePositionManager.New()
    self.battlePositionManager:OnInit(self)
    self.battleCameraManager=BattleCameraManager.New()
    self.battleCameraManager:OnInit(self,scene_mask_col,cam_trans)
    self.battleCache = battleCache
    AddEventListener(self)
end


local function GetCacheGame(self,prefab)
    if self.battleCache ~= nil then
        local list = self.battleCache[prefab]
        if list ~= nil and #list > 0 then
            return table.remove(list)
        end
    end
    return nil
end


local function Update(self)
    self.battleRoleViewManager:Update()
    --if CS.UnityEngine.Input.GetKeyDown(CS.UnityEngine.KeyCode.B) then
    --    ForceEndActorAction(self)
    --elseif CS.UnityEngine.Input.GetKeyDown(CS.UnityEngine.KeyCode.A) then
    --    SinglePlayAction(self)
    --elseif CS.UnityEngine.Input.GetKeyDown(CS.UnityEngine.KeyCode.G) then
    --    self.actions = {}
    --    ResetBattleView(self)
    --    SinglePlayAction(self)
    --end
end


local function OnDestroy(self)
    self.battleRoleViewManager:OnDestroy()
    self.battlePositionManager:OnDestroy()
    self.isDestory = true
    self.actions = {}
    self.curActionEffectTargets = nil
    ResetTimeScale(self)
    RemoveEventListener(self)
end



BattleViewContext.__init=__init
BattleViewContext.OnInit=OnInit
BattleViewContext.BlockAction = BlockAction
BattleViewContext.Update=Update
BattleViewContext.OnDestroy=OnDestroy
BattleViewContext.SetKillCam=SetKillCam
BattleViewContext.TriggerKillCam=TriggerKillCam
BattleViewContext.GetCacheGame = GetCacheGame
BattleViewContext.SinglePlayAction = SinglePlayAction
BattleViewContext.SomeoneSkillOver = SomeoneSkillOver
BattleViewContext.BattleEndCheck = BattleEndCheck
BattleViewContext.CallGuardDead = CallGuardDead
BattleViewContext.ChangeTimeScale = ChangeTimeScale
BattleViewContext.PlayCallOverEffect = PlayCallOverEffect
return BattleViewContext