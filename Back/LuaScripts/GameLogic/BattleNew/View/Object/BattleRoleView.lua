---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by guoyu.
--- DateTime: 2018/12/21 10:10
---
local BattleRoleView=BaseClass("BattleRoleView")
BattleRoleView.AnimName_Name_Login="login"
BattleRoleView.AnimName_Name_Idle="idle"
BattleRoleView.AnimName_Name_Die="die"
BattleRoleView.AnimName_Name_Die2="hit_3"

local BattleAssistFunction= require "GameLogic.BattleNew.BattleAssistFunction"
local BattleConstConfig = require "GameLogic.BattleNew.BattleConstConfig"
local BattleSkillEffectViewFactory=require"GameLogic.BattleNew.View.BattleSkillEffectViewFactory"
local choose_effect_path = "Art/EffectRes/Common/FX_c_pre fight.prefab"
local battle_direction_path = "Art/UI_3D/Pefabs/battlearrow.prefab"
local power_blue_SHL_begin = "Art/EffectRes/Common/FX_c_power_blue01.prefab"
local power_blue_SHL_end = "Art/EffectRes/Common/FX_c_power_blue02.prefab"
local power_blue_JLR_begin = "Art/EffectRes/Common/FX_c_power_blue03.prefab"
local power_blue_JLR_end = "Art/EffectRes/Common/FX_c_power_blue04.prefab"
local function __init(self)
    --表现层上下文
    self.viewContext=nil
    --GameObject
    self.gameObject=nil
    --Transform
    self.transform=nil
    --Animator
    self.animator=nil
    --playAbleDirector
    self.playAbleDirector=nil
    --死亡消融组件
    self.fxController=nil
    --当前状态
    self.currentState=nil
    --技能timeLines
    self.timeLines=nil
    --召唤技能TimeLine
    self.guardianTimeLine=nil
    --预备timeline
    self.guardianPreTimeLine = nil
    --胜利庆祝TimeLine
    self.winTimeLine=nil
    --缓存路径
    self.path=nil
    self.skillVCam=nil
    self.commonVCamGroup0=nil
    self.commonVCamGroup1=nil

    --技能效果特效
    self.effectViews={}
    --技能释放过程中隐藏的特效
    self.hideEffectViews={}
    --角色配置
    self.roleConfig=nil
    --是否是最后一个角色
    self.lastDeadRole = false
    --血量变化的单位
    self.blood_change = nil
    --是否是连击技能
    self.show_special_blood = false
    self.useSkillState = 0
    --特殊死亡  不进入死亡状态 直接进入消亡状态
    self.special_dead = 0
    --战斗位置
    self.battlePosition = 0
    --隐藏总伤害
    self.hideTotalHurt = 0
    --总伤害值
    self.totalHurt = 0
    --播放声音
    self.playHitVoice = false
    --显示层死亡
    self.viewDead = false
end
--获取单位角色高度
local function GetBloodOffet(self)
    if self.roleConfig~= nil then
        return self.roleConfig.PrefabHeight*self.roleConfig.PrefabZoom
    else
        return 2
    end
end
--操作血条
local function HandleBloodFunc(self,hide)
    --单位只取一次  因为可能多次掉血
    local targetRole = {}
    if self.skillCases ~= nil then
        for p, q in ipairs(self.skillCases) do
            for k,v in ipairs(q) do
                if targetRole[v.entityId] == nil or not targetRole[v.entityId][v.teamId] then
                    if  self.show_special_blood then
                        self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYSPECIALBLOOD,{isShow = false,id=v.entityId})
                    else
                        self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYINITPASSBLOOD,{isShow = false,id=v.entityId,team=v.teamId})
                    end
                    if targetRole[v.entityId] == nil then
                        targetRole[v.entityId] = {[v.teamId] = true}
                    else
                        targetRole[v.entityId][v.teamId] = true
                    end
                end
            end
        end
    end
end

local function ChangeBloodVal(cur_blood_change,change_val)
    if change_val >= 0 then
        cur_blood_change.newHp = cur_blood_change.newHp + change_val
        return
    end
    change_val = math.abs(change_val)
    if cur_blood_change.newShield > 0 then
        if change_val > cur_blood_change.newShield then
            cur_blood_change.newHp = cur_blood_change.newHp - change_val+cur_blood_change.newShield
            cur_blood_change.newShield = 0
        else
            cur_blood_change.newShield = cur_blood_change.newShield - change_val
        end
    else
        cur_blood_change.newHp = cur_blood_change.newHp - change_val
    end
end

local function SimpleHandleSkil(self,v)
    local cur_blood_change = v.blood
    if v.effect ~= nil then
        for j,z in ipairs(v.effect) do
            --除了掉血部分 其他只允许执行一次
            if z.type == 1 then
                self:OpreateHp(Mathf.Ceil(z.hurt),z.crit,z.hurtType)
                if cur_blood_change ~= nil and cur_blood_change.blood_show then
                    ChangeBloodVal(cur_blood_change,Mathf.Ceil(z.hurt))
                end
            elseif z.type == 2 then
                if z.hurt ~= 0 then
                    self:OpreateHp(Mathf.Ceil(z.hurt),z.crit,z.hurtType)
                    if cur_blood_change ~= nil and cur_blood_change.blood_show then
                        ChangeBloodVal(cur_blood_change,Mathf.Ceil(z.hurt))
                    end
                end
            elseif z.type == 3 then
                if z.entityId > 0 then
                    self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYPLAYERDROPCRY,z.teamId,z.entityId,z.crytalType,z.crytalCount)
                end
            end
            self:PlaySkillEffect(z)
        end

        if cur_blood_change ~= nil then
            if cur_blood_change.blood_show then
                ChangeBloodVal(cur_blood_change,Mathf.Ceil(cur_blood_change.shieldHurt))
                self:OnSomeOneBloodShow(cur_blood_change,v.effect,false)
                self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYINITPASSBLOOD,{isShow = false,id=self.entity.entityId,team=self.entity.teamId})
            end
            if cur_blood_change.finalHp <= 0 then
                self.viewDead = true
            end
        end
    end
end

local function SkillCaseHandler(self,msg,param1,param2,param3,param4,param5)
    if msg=="hit" then
        --self.skillCaseIndex=self.skillCaseIndex+1
        if self.skillCases ~= nil then
            local skillCase = self.skillCases[param1]
            if skillCase~=nil  then
                for k,v in ipairs(skillCase) do
                    local view=self.viewContext.battleRoleViewManager:GetRoleViewById(v.teamId,v.entityId)
                    local cur_blood_change = v.blood
                    local cur_major_effect = false
                    if v.effect ~= nil then
                        for j,z in ipairs(v.effect) do
                            --除了掉血部分 其他只允许执行一次
                            if z.type == 1 then
                                if z.hurtType == 5 or z.hurtType == 6 then
                                    view:ShowEffectName(z)
                                else
                                    local tempHurt = Mathf.Ceil(z.hurt*param2)
                                    self.totalHurt = self.totalHurt + tempHurt
                                    view:OpreateHp(tempHurt,z.crit,z.hurtType,self.totalHurt,self.hideTotalHurt)
                                    view.fxController:Flash(0.16)
                                    if cur_blood_change.blood_show then
                                        ChangeBloodVal(cur_blood_change,tempHurt)
                                    end
                                end
                                if z.majorEffect == true then
                                    cur_major_effect = true
                                end
                            elseif z.type == 2 then
                                if not skillCase.isUse then
                                    if z.hurt ~= 0 then
                                        view:OpreateHp(Mathf.Ceil(z.hurt),z.crit,z.hurtType)
                                        if cur_blood_change.blood_show then
                                            ChangeBloodVal(cur_blood_change,Mathf.Ceil(z.hurt))
                                        end
                                    end
                                end
                                if z.majorEffect == true then
                                    cur_major_effect = true
                                end
                            elseif z.type == 3 then
                                if not skillCase.isUse then
                                    local change_cry = nil
                                    --更新水晶
                                    if view.entity.playerType==BattleEnum.BattlePlayerType.ENEMY then
                                        change_cry = {nil,{add={[z.crytalType] = z.crytalCount}}}
                                        --self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUICRYCHANGE,{nil,{add={[z.crytalType] = z.crytalCount}}})
                                    else
                                        change_cry = {{add={[z.crytalType] = z.crytalCount}},nil}
                                        --self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUICRYCHANGE,{{add={[z.crytalType] = z.crytalCount}},nil})
                                    end

                                    if z.entityId > 0 then
                                        self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYPLAYERDROPCRY,z.teamId,z.entityId,z.crytalType,z.crytalCount,change_cry)
                                    else
                                        UIManager:GetInstance():Broadcast(UIMessageNames.UIBATTLE_CRYSTAL_CHANGE,change_cry)
                                    end
                                end
                                if z.majorEffect == true then
                                    cur_major_effect = true
                                end
                            elseif z.type == 5 or z.hurtType == 5 or z.hurtType == 6 then
                                view:ShowEffectName(z)
                            end
                            if not skillCase.isUse then
                                view:PlaySkillEffect(z,self.show_special_blood)
                            end
                        end
                    end
                    if cur_blood_change.blood_show then
                        ChangeBloodVal(cur_blood_change,Mathf.Ceil(cur_blood_change.shieldHurt)*param2)
                        view:OnSomeOneBloodShow(cur_blood_change,v.effect,self.show_special_blood and cur_major_effect)
                    end
                    if cur_blood_change.finalHp <= 0 and self.isLastSkill and not self.show_special_blood then
                        --判断是否是最后一个角色
                        local role = view.entity
                        local player=role.group.player
                        if player.playerType == BattleEnum.BattlePlayerType.ENEMY then
                            if param3 ~= nil and #param3>0 then
                                local timescale = string.split(param3,"#",1,true)
                                self.viewContext:ChangeTimeScale(tonumber(timescale[1]))
                                TimerManager:GetInstance():SimpleTimerArgs(tonumber(timescale[2]), function()
                                    self.viewContext:ChangeTimeScale(1)
                                end, nil, true, false, true)
                                self.viewContext:TriggerKillCam(role)
                            end
                        end
                    end
                end
                skillCase.isUse = true
            end
        else
            Logger.LogError("SkillCaseHandler hit event 错误  没有cases ")
        end
    elseif msg == "total_hit" then
        self.hideTotalHurt = 1
    elseif msg=="combo" then
        local data={entityId=self.entity.entityId,count=param1,teamId = self.entity.playerType}
        self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUICOMBO,data)
    elseif msg == "blood2" then
        if param1 == 1 then
            HandleBloodFunc(self,0)
        else
            HandleBloodFunc(self,1)
        end
    elseif msg == "cutin" then
        if self.entity.playerType==BattleEnum.BattlePlayerType.MINE then
            local showViewId =BattleAssistFunction.GetCardIdByTeamAndEntityId(self.entity.playerType,self.entity.entityId)
            self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUICUTIN,showViewId,param1)
        end
    elseif msg == "callcam" then
        LJAudioManger:GetInstance():PlayVoice("UI_Camera_08")
        self.viewContext.battleCameraManager:PveCallEndAnim()
    elseif msg=="callmask" then
        self.viewContext.battleCameraManager:CameraMaskAction(0,0)
        self.viewContext.battleRoleViewManager:ResetMoveBattleRole(self.relRoleIds)
    elseif msg == "3skillcam" then
        if param1 == 1 then
            --加载天空盒
            self.viewContext.battleCameraManager:CameraBackgroudMask(1)
            self.viewContext.battleRoleViewManager:MoveNoBattleRole(self.relRoleIds)
        else
            self.viewContext.battleRoleViewManager:ResetMoveBattleRole(self.relRoleIds)
            self.viewContext.battleCameraManager:CameraBackgroudMask(0)
            self.viewContext.battleCameraManager:PveCallEndAnim()

            --for m,skillCase in ipairs(self.skillCases) do
            --    if skillCase~=nil  then
            --        for k,v in ipairs(skillCase) do
            --            local view=self.viewContext.battleRoleViewManager:GetRoleViewById(v.teamId,v.entityId)
            --            if view ~= nil and view.entity.hp > 0 then
            --                view:SpecialSkillShowEffect()
            --            end
            --        end
            --    end
            --end
        end
    elseif msg == "result" then
        if not self.playTimeResult then
            self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUIRESULT,self.viewContext.settlement)
            self.playTimeResult = true
        end
    elseif msg == "audio" then
        if param1 == 0 then
            if param3 ~= nil and #param3 > 0 then
                LJAudioManger:GetInstance():PlayVoice(param3)
            end
        elseif param1 == 1 then
            if self.isExclusiveCall then
                if self.callTarget ~=nil and self.callTarget.roleConfig.ExclusiveCall ~= nil and #self.callTarget.roleConfig.ExclusiveCall > 0 then
                    LJAudioManger:GetInstance():PlayVoice(self.callTarget.roleConfig.ExclusiveCall)
                end
            else
                if self.roleConfig.ExclusiveCall ~= nil and #self.roleConfig.ExclusiveCall > 0 then
                    LJAudioManger:GetInstance():PlayVoice(self.roleConfig.ExclusiveCall)
                end
            end
        elseif param1 == 2 then
            if self.callTarget ~=nil and self.callTarget.roleConfig.CommonCall ~= nil and #self.callTarget.roleConfig.CommonCall > 0 then
                LJAudioManger:GetInstance():PlayVoice(self.callTarget.roleConfig.CommonCall)
            end
        end
    elseif msg == "guide" then --触发新手
        if  GuideManager:GetInstance():CheckRunning() and GuideManager:GetInstance():GetGuideGroup() == 7 then
            UIManager:GetInstance():Broadcast(UIMessageNames.UIBATTLE_RESET_ENTER,-1)
            self.skillEvent = nil
        end
    elseif msg == "active" then --是否激活
        if param1 == 0 then
            self.gameObject:SetActive(param2 == 1)
        else
            if self.skillTargetsView ~= nil then
                for i, v in ipairs(self.skillTargetsView) do
                    if v ~= nil then
                        v.gameObject:SetActive(param2 == 1)
                    end
                end
            end
        end
    elseif msg == "visiable" then --是否渲染
        local function SetRender(roleView,active)
            if roleView == nil then
                return
            end
            if roleView.roleRenders == nil and not IsNull(roleView.gameObject) then
                roleView.roleRenders =  roleView.gameObject:GetComponentsInChildren(typeof(CS.UnityEngine.Renderer))
            end
            if roleView.roleRenders ~= nil then
                for i = 0, roleView.roleRenders.Length - 1 do
                    roleView.roleRenders[i].enabled = active
                end
            end
        end
        if param1 == 0 then
            SetRender(self,param2 == 1)
        else
            if self.skillTargetsView ~= nil then
                for i, v in ipairs(self.skillTargetsView) do
                    SetRender(v,param2 == 1)
                end
            end
        end
    elseif msg=="anim_evt" then
        local function PlayOtherAnim()
            if self.skillTargetsView ~= nil then
                for i, v in ipairs(self.skillTargetsView) do
                    if self.deadTargets ~= nil and self.deadTargets[v.gameObject.name] and param4 then
                        if not self.playHitVoice then
                            if not isNilOrEmpty(v.roleConfig.HitSound)  then
                                LJAudioManger:GetInstance():PlayVoice(v.roleConfig.HitSound)
                            end
                            self.playHitVoice = true
                        end
                        if self.isLastSkill then
                            v.lastDeadRole = true
                            v:CheckDead()
                        else
                            v:CheckDead()
                        end
                    else
                        if not self.playHitVoice and string.startswith(param3,"hit",true) then
                            if not isNilOrEmpty(v.roleConfig.HitSound)  then
                                LJAudioManger:GetInstance():PlayVoice(v.roleConfig.HitSound)
                            end
                            self.playHitVoice = true
                        end
                        if param3 ~= "hit_n" then
                            if self.intervene then
                                if self.lastIntervene == v then
                                    v:BeHitState(param3,param2,param5)
                                end
                            else
                                v:BeHitState(param3,param2,param5)
                            end
                        end
                    end
                end
            end
        end
        if self.actionType == 0 then
            if param1 == 0 then
                if self.callTarget ~= nil then
                    self.callTarget.gameObject:SetActive(true)
                    self.callTarget:Play(param3,param2,param5)
                end
            else
                PlayOtherAnim()
            end
        else
            PlayOtherAnim()
        end
    elseif msg == "summonhit" then
        if self.callTarget ~= nil then
            self.viewContext:PlayCallOverEffect()
        end
    elseif msg == "summonattack" then
        if self.callTarget ~= nil then
            self.callTarget:ShowCallDownEffect()
        end
    end
end

local function SpecialSkillShowEffect(self)
    for i, v in ipairs(self.hideEffectViews) do
        v:ShowAndHideEffect(true)
    end
    self.hideEffectViews = {}
end
--生成新特效
local function AddNewEffect(self,effectId,fxConfig,FxId,effectLayer,hide)
    local effectView=BattleSkillEffectViewFactory.CreateBattleSkillEffectView(effectId,self,fxConfig,FxId,effectLayer,hide)
    if effectView~=nil then
        self:AddEffectView(effectView)
        if hide then
            table.insert(self.hideEffectViews,effectView)
        end
    end
end
--播放特效
local function PlaySkillEffect(self,v,hide_buff)
    if v.del then
        local effectView = self:GetEffectViewById(v.effectId)
        if effectView ~= nil then
            effectView:OnDestroy()
            local effectConfig=DataUtil.GetData("skill_effect")[v.effectId]
            if effectConfig ~= nil  and effectConfig.FxDisappear ~=nil and effectConfig.FxDisappear > 0  then
                local fxConfig=DataUtil.GetData("fx_config")[effectConfig.FxDisappear]
                if fxConfig.prefab_Name ~= nil or #fxConfig.prefab_Name > 0 then
                    AddNewEffect(self,v.effectId,fxConfig,effectConfig.FxDisappear,v.layer,hide_buff and effectConfig.Type == 4)
                end
            end
        end
    else
        --判断身上是否有
        local effectView = self:GetEffectViewById(v.effectId)
        if effectView ~= nil then
            effectView:OnRefresh(v.layer)
        else
            --查找特效
            local effectConfig=DataUtil.GetData("skill_effect")[v.effectId]
            if effectConfig ~= nil  and effectConfig.FxId ~= nil and effectConfig.FxId ~=0  then
                local fxConfig=DataUtil.GetData("fx_config")[effectConfig.FxId]
                if fxConfig.prefab_Name ~= nil or #fxConfig.prefab_Name > 0 then
                    AddNewEffect(self,v.effectId,fxConfig,effectConfig.FxId,v.layer,hide_buff and effectConfig.Type == 4)
                end
            end
        end
    end
end

local function OnInit(self,context,entity,gameObject,path)
    self.viewDead = false
    self.viewContext=context
    self.gameObject=gameObject
    self.path=path
    self.entity = entity
    self.transform=self.gameObject.transform
    self.animator=self.transform:GetComponentInChildren(typeof(CS.UnityEngine.Animator))
    self.playAbleDirector=self.transform:GetComponentInChildren(typeof(CS.UnityEngine.Playables.PlayableDirector))
    self.fxController=self.transform:GetComponentInChildren(typeof(CS.RoleFxController))
    self.effectViews={}
    local showViewId =BattleAssistFunction.GetCardIdByTeamAndEntityId(self.entity.playerType,self.entity.entityId)
    self.roleConfig = DataUtil.GetData("battle_role_config")[showViewId]
    self.skillVCam=CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.GetSkillVCam();
    local camAnchor = self.skillVCam.transform.parent;
    camAnchor:SetParent(self.transform,false);
    self.transform.localScale=Vector3.New(self.roleConfig.PrefabZoom,self.roleConfig.PrefabZoom,self.roleConfig.PrefabZoom)
    --set self.skillVCam.transform.parent's local scale to 1.4
    --判断是不是守护灵
    local roleCard = DataUtil.GetData("card")[showViewId]
    if roleCard ~= nil and roleCard.Type == 1 then
        local scaleValue =1.4 / self.transform.localScale.x;
        camAnchor.localScale=Vector3(scaleValue,scaleValue,scaleValue)
    end
    for i, v in pairs(self.entity.effects) do
        if entity:CheckIsMainRole() or v.isInitEffect then
            PlaySkillEffect(self,v)
        end
    end
    self:ChangeState(BattleEnum.BattleRoleState.IDLE)
    self:ChangeBattlePosition(BattleEnum.BattlePosition.FRONT)
    self:ChangeParent()
end

local function GetHpAndShield(self,data)
    local shieldVal = 0
    local shieldPer = 0
    local oldhp = 0
    local oldShield = 0
    local curhp = 0
    if data ~= nil then
        oldhp = data.oldHp/self.entity.maxHp
        curhp = data.newHp/self.entity.maxHp
        if data.maxShield > 0 then
            oldShield = data.oldShield/data.maxShield
            shieldVal = data.newShield/data.maxShield
            shieldPer = data.maxShield/self.entity.maxHp
            if shieldPer > 1 then
                shieldPer = 1
            end
        end
        data.oldhp = data.newHp
        data.oldShield = data.newShield
    else
        curhp = self.entity.currentHp
        oldhp = curhp
        local shieldCur,shieldMax = self.entity:GetShieldVal()
        if shieldMax > 0 then
            shieldVal = shieldCur/shieldMax
            oldShield = shieldVal
            shieldPer = shieldMax/self.entity.maxHp
            if shieldPer > 1 then
                shieldPer = 1
            end
        end
    end
    return shieldVal ,shieldPer,oldhp,oldShield,curhp
end

--获取当前血条数据
local function GetBloodData(self,data,effects)

    if self.battlePosition==BattleEnum.BattlePosition.BACK then
        return {isShow = false,id=self.entity.entityId,team=self.entity.teamId}
    elseif data == nil and self.entity.hp <= 0 then
        return {isShow = false,id=self.entity.entityId,team=self.entity.teamId}
    end

    local effectData={}
    if effects == nil then
        effects = self.entity.effects
    end
    for k,v in ipairs(effects) do
        if v.lastTime ~= nil and v.lastTime >0 then
            table.insert(effectData,{id=v.effectId,layer=v.layer,time=v.lastTime})
        end
    end
    local cry_type,cry_max,cry_num,cry_init_max = self.entity:GetCryCost()
    local shieldVal ,shieldPer,oldhp,oldShield,curhp = GetHpAndShield(self,data)
    return  {team=self.entity.teamId,transform=self.fxController:GetAnchorTrans(9),offset=GetBloodOffet(self),
             val=curhp,id=self.entity.entityId,effects=effectData,shieldPer = shieldPer,
             shieldVal = shieldVal,isShow=true,oldVal = oldhp,oldShield = oldShield,
            cry_type = cry_type,cry_max = cry_max,cry_num = cry_num,playerType = self.entity.playerType,cry_init_max = cry_init_max}

end

local function GetSpecialBloodData(self,data)
    if self.battlePosition==BattleEnum.BattlePosition.BACK then
        return {isShow = false,id=self.entity.entityId}
    end
    local shieldVal ,shieldPer,oldhp,oldShield,curhp = GetHpAndShield(self,data)
    return  {team=self.entity.teamId,val=curhp,id=self.entity.entityId,shieldPer = shieldPer,
             shieldVal = shieldVal,isShow=true,oldVal = oldhp,oldShield = oldShield,playerType = self.entity.playerType}
end


local function OnSomeOneBloodShow(self,data,effect,show_special)
    if show_special then
        self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYSPECIALBLOOD,GetSpecialBloodData(self,data))
    else
        self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYINITPASSBLOOD,GetBloodData(self,data,effect))
    end
end

local function HideChooseSkillEffect(self)
    if not IsNull(self.choose_effect_game) then
        GameObjectPool:GetInstance():RecycleGameObject(choose_effect_path,self.choose_effect_game)
        self.choose_effect_game = nil
    end
end
local function PlayChooseSkillEffect(self)
    GameObjectPool:GetInstance():GetGameObjectAsync(choose_effect_path,function(go)
        if not IsNull(go) then
            self.choose_effect_game = go
            self.choose_effect_game.transform.position = self.transform.position
        end
    end)
    TimerManager:GetInstance():SimpleTimerArgs(1,function()
        HideChooseSkillEffect(self)
    end,nil,true)
end



local function ShowOrHideEffect(self,_active)
    for i=1,#self.effectViews do
        self.effectViews[i]:ShowAndHideEffect(_active)
    end
end

--根据位置设置父节点
local function ChangeParent(self)

    local parentTranform=self.viewContext.battlePositionManager:GetTransFormById(self.entity.playerType,self.entity.position+1,self.battlePosition)

    self.transform:SetParent(parentTranform)
    self.transform.localPosition=Vector3.zero
    self.transform.localEulerAngles=Vector3.zero


    if self.entity.playerType==BattleEnum.BattlePlayerType.MINE then
        if self.commonVCamGroup0==nil then
            self.commonVCamGroup0=CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.GetCommoneVCamGrop_Simple(
                    BattleConstConfig.CommonVCam0Info.name,
                    BattleConstConfig.CommonVCam0Info.followPos,
                    BattleConstConfig.CommonVCam0Info.followAngle,
                    BattleConstConfig.CommonVCam0Info.followFov,
                    BattleConstConfig.CommonVCam0Info.follow,
                    BattleConstConfig.CommonVCam0Info.lookAt
            );
            self.commonVCamGroup0.transform:SetParent(parentTranform.parent);
            self.commonVCamGroup0.transform.localPosition=Vector3.zero
            self.commonVCamGroup0.transform.localEulerAngles=Vector3.zero
        end
        if self.commonVCamGroup1==nil then
            self.commonVCamGroup1=CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.GetCommoneVCamGrop_Simple(
                    BattleConstConfig.CommonVCam1Info.name,
                    BattleConstConfig.CommonVCam1Info.followPos,
                    BattleConstConfig.CommonVCam1Info.followAngle,
                    BattleConstConfig.CommonVCam1Info.followFov,
                    BattleConstConfig.CommonVCam1Info.follow,
                    BattleConstConfig.CommonVCam1Info.lookAt
            );
            self.commonVCamGroup1.transform:SetParent(parentTranform.parent);
            self.commonVCamGroup1.transform.localPosition=Vector3.zero
            self.commonVCamGroup1.transform.localEulerAngles=Vector3.zero
        end
    end

    if self.battlePosition==BattleEnum.BattlePosition.FRONT then
        self.gameObject:SetActive(true)
        ShowOrHideEffect(self,true)
    elseif   self.battlePosition==BattleEnum.BattlePosition.BACK  then
        self.gameObject:SetActive(false)
        ShowOrHideEffect(self,false)
    end

end





local function FillTimeLines(self,skillId,timeline)
    if self.timeLines==nil then
        self.timeLines={}
    end
    self.timeLines[skillId]=timeline
end

local function SetGuardianTimeLine(self,timeLine)
    self.guardianTimeLine=timeLine
    --self.preTimeLine = preTimeLine
    --self.guardianTimeLine_e = timeline_e
end

local function SetWinTimeLine(self,timeLine,time)
    self.winTimeLine=timeLine
    self.winTimeLine_time = time
end
local function Play(self,animName,fade,start)
    if not self.animator:HasState(0,CS.UnityEngine.Animator.StringToHash(animName))then
        return
    end
    local info =  self.animator:GetCurrentAnimatorStateInfo(0)
    if info:IsName(animName) then
        return
    end
    local startN = 0
    if start ~= nil then
        startN = start
    end
    if fade ~= nil and fade>0 then
        self.animator:CrossFade(animName,fade,0,startN,0)
    else

        self.animator:Play(animName,0,startN)
    end
end
--检测动画播放时长
local function CheckAnimState(self,animName)
    local info =  self.animator:GetCurrentAnimatorStateInfo(0)
    if info:IsName(animName) then
        return info.normalizedTime
    else
        return 0
    end
end



local function AddNewSkillTime(self,skillData)
    local viewDataId = math.floor(BattleAssistFunction.GetCardIdByTeamAndEntityId(self.entity.playerType,self.entity.entityId))
    local timeline_time = DataUtil.GetData("timeline_time")
    if skillData.SkillType==2 then
        local ccskillData=DataUtil.GetData("battle_ccskill_config")[skillData.ShowId]
        if ccskillData~=nil and  ccskillData.skillTimeLine~=nil then--插槽通用技能
            local time_key = viewDataId.."_"..ccskillData.skillTimeLine
            local find_val = BattleAssistFunction.FindSkillTimeLine(time_key)
            if find_val ~= nil then
                local timeLine = {}
                if find_val.Prepare ~= nil then
                    local res_timer = {res = false,time = 0,type = 1}
                    if timeline_time[find_val.Prepare] ~= nil then
                        res_timer.time = timeline_time[find_val.Prepare].duration
                        res_timer.event = timeline_time[find_val.Prepare].event
                    end
                    res_timer.res = ResourcesManager:GetInstance():CoLoadAsync(find_val.Prepare,typeof(CS.UnityEngine.Timeline.TimelineAsset))
                    if res_timer.res ~= nil then
                        table.insert(timeLine,res_timer)
                    else
                        Logger.LogError("资源未查找到  "..find_val.Prepare)
                    end

                end
                if find_val.Action ~= nil  then
                    local res_timer = {res = false,time = 0,type = 2}
                    if timeline_time[find_val.Action] ~= nil then
                        res_timer.time = timeline_time[find_val.Action].duration
                        res_timer.event = timeline_time[find_val.Action].event
                    end
                    res_timer.res = ResourcesManager:GetInstance():CoLoadAsync(find_val.Action,typeof(CS.UnityEngine.Timeline.TimelineAsset))
                    if res_timer.res ~= nil then
                        table.insert(timeLine,res_timer)
                    else
                        Logger.LogError("资源未查找到  "..find_val.Action)
                    end
                end
                if find_val.Return ~= nil then
                    local res_timer = {res = false,time = 0,re_speed = 1,type = 3}
                    if timeline_time[find_val.Return] ~= nil then
                        res_timer.time = timeline_time[find_val.Return].duration
                        res_timer.event = timeline_time[find_val.Return].event
                        if find_val.ReturnSpeed ~= nil then
                            res_timer.re_speed = tonumber(find_val.ReturnSpeed)
                        end
                    end
                    res_timer.res = ResourcesManager:GetInstance():CoLoadAsync(find_val.Return,typeof(CS.UnityEngine.Timeline.TimelineAsset))
                    if res_timer.res ~= nil then
                        table.insert(timeLine,res_timer)
                    else
                        Logger.LogError("资源未查找到  "..find_val.Return)
                    end
                end
                if #timeLine > 0 then
                    local key=math.floor(skillData.ShowId).."-1"
                    self:FillTimeLines(key,timeLine)
                end
            end
        end
    end
end
--创建event
local function CreateEvent(data)
    local result = {}
    if data ~= nil then
        --最后一个被击动画
        local lastIndex = -1
        local lastTime = -1
        for i, v in ipairs(data) do
            table.insert(result,{time = v.time,msg = v.msg,lParam = v.lParam,fParam=v.fParam,sParam=v.sParam,aParam = v.aParam})
            if v.msg == "anim_evt" and string.startswith(v.sParam,"hit",true) and v.time > lastTime then
                lastIndex = i
                lastTime = v.time
            end
        end
        if lastIndex > 0 then
            result[lastIndex].isLast = true
        end
        table.sort(result,function(a,b) return a.time>b.time  end)
    end
    return result
end


local function UseNextAction(self)
    if self.intervene then
        --主目标死亡后 不需要移动动画
        if self.mainTargetDead then
            self.lastIntervene.transform.position = self.oldIntervenePos
            self.viewContext:SomeoneSkillOver()
        else
            self.lastIntervene:Play("exskill_2")
            self.interveneTween = LuaTweener.TransMoveTo(self.lastIntervene.transform,self.lastIntervene.transform.position,self.oldIntervenePos,0.5,EaseFormula.Linear,function()
                self.viewContext:SomeoneSkillOver()
                self.interveneTween = nil
            end)
        end

        self.intervene = false
    else
        self.viewContext:SomeoneSkillOver()
    end
end

--播放技能的timeline
local function PlaySkillTimeLine(self)
    --TO Do
    --self.viewContext:SomeoneSkillOver()
    --self:ChangeState(BattleEnum.BattleRoleState.IDLE)
    local curTimeData = self.timeLineGroup[self.timeLineIndex]
    if curTimeData == nil then
        if self.origeParentFor ~= nil then
            self.transform.parent.parent.forward = self.origeParentFor
        end
        --位置归位
        self.transform.parent.localPosition = Vector3.zero
        self.transform.parent.localEulerAngles = Vector3.zero
        self.gameObject:SetActive(true)
        self:ChangeState(BattleEnum.BattleRoleState.IDLE)
        --如果前一个阶段不是返回阶段 也结束
        if self.timeLineGroup[self.timeLineIndex-1].type ~= 3 then
            if self.returnType == 1 then
                self:OnSomeOneFinishSkill(1)
                UseNextAction(self)
            end
        end
        --如果状态是普通状态
        if self.returnType ~= 1 then
            self:OnSomeOneFinishSkill(1)
            UseNextAction(self)
        end
        return
    else
        if curTimeData.type == 3 then
            --如果下一个技能释放者不是自己
            if self.returnType == 1 then
                self:OnSomeOneFinishSkill(1)
                UseNextAction(self)
            end
        end
    end
    if curTimeData.type == 2 then
        if not self.show_special_blood then --压黑取消计时
            self.useSkillState = 1
        end
    end
    self.playAbleDirector.playableAsset = curTimeData.res
    local Camgroup=nil
    local useCommonCam=false
    local followAnchor=-1
    local lookAtAnchor = -1
    local camFollowAttacker = true
    local lookAttAttacker=false
    local fieldNodes=self.viewContext.battlePositionManager:GetFieldNodesByPlayerType(self.entity.playerType)
    if self.entity.playerType==BattleEnum.BattlePlayerType.MINE then
        Camgroup=self.commonVCamGroup0
        followAnchor=BattleConstConfig.CommonVCam0Info.followAnchor
        lookAtAnchor = BattleConstConfig.CommonVCam0Info.lookAtAnchor
    elseif self.entity.playerType==BattleEnum.BattlePlayerType.ENEMY  then
        if self.mainTarget~=nil and self.mainTarget.entity.playerType~=self.entity.playerType then
            Camgroup=self.mainTarget.commonVCamGroup1
            followAnchor=BattleConstConfig.CommonVCam1Info.followAnchor
            lookAtAnchor = BattleConstConfig.CommonVCam1Info.lookAtAnchor
            camFollowAttacker = false
        end
        if not self.show_special_blood then--表示可能连击技能，要用自身的相机动画
            useCommonCam=true
        end
    end
    local mainGame = nil
    if self.mainTarget ~= nil then
        mainGame = self.mainTarget.gameObject
        self.viewContext:SetKillCam(self.mainTarget)
    end
    --当这次攻击是由敌方发起时,需要判断这个技能是否是触发三连击的技能,如果不是触发三连击的技能,使用通用镜头.
    CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.BindingRoles(
            self.playAbleDirector,
            self.gameObject,mainGame,self.otherTargets,
            self.viewContext.battleCameraManager.camera.gameObject,
            self.skillVCam,
            Camgroup,fieldNodes,
            useCommonCam,--是否使用通用镜头
            camFollowAttacker,
            followAnchor,
            lookAttAttacker,
            lookAtAnchor,
            self.attackOffset,0)


    --选择技能镜头动画控制轨道
    --己方使用技能,使用SkillCamera
    --敌方使用技能,使用SkillCamera_Enemy(如果存在)
    local isEnemy = self.entity.playerType==BattleEnum.BattlePlayerType.ENEMY
    local camTrackIndex = 0
    if isEnemy then
        camTrackIndex = 1
    end
    CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.SelectTracks(self.playAbleDirector,{"SkillCamera","SkillCamera_Enemy"},camTrackIndex)



    self.actionUseTime =  curTimeData.time
    self.timer = Time.time
    if self.returnType == 2 and curTimeData.type == 3 then
        self.actionUseTime =  self.actionUseTime/curTimeData.re_speed
        self.playAbleDirector.timeUpdateMode = CS.UnityEngine.Playables.DirectorUpdateMode.Manual
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.AddTimelineScale(self.playAbleDirector,curTimeData.re_speed)
    else
        self.playAbleDirector.timeUpdateMode = CS.UnityEngine.Playables.DirectorUpdateMode.GameTime
        self.playAbleDirector:Play()
    end
    --屏幕提层
    if curTimeData.type ~= 3 then
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.UpdateRoleRender(self.gameObject,mainGame,self.otherTargets,1)
    end
    self.playHitVoice = false
    self.skillEvent = CreateEvent(curTimeData.event)
    self.timeLineIndex = self.timeLineIndex+1
end


local function ReadyPlayTimeline(self,skillId,doubleHit,isGuaidSkill,simpleThreeBeat)
    self.relRoleIds[self.entity.entityId] = self.entity.teamId
    if self.mainTarget~=nil and self.mainTarget.entity.playerType~=self.entity.playerType then
        local _lookAtPoint = self.mainTarget.transform.position
        local _tarDir = (_lookAtPoint - self.transform.position).normalized
        self.origeParentFor = self.transform.parent.parent.forward
        self.transform.parent.parent.forward = _tarDir
        local distance=Vector3.Distance(_lookAtPoint,self.transform.position)
        --Logger.Log("与目标距离为.."..distance)
        self.attackOffset=distance-7.5*self.roleConfig.PrefabZoom
    end
    local skillData=DataUtil.GetData("skill")[skillId]
    self.show_special_blood = skillData.DoubleHit > 0
    if not self.show_special_blood then
        self.viewContext.battleCameraManager:CameraMaskAction(1,1)
    else
        UIManager:GetInstance():Broadcast(UIMessageNames.UIBATTLE_PLAY_CRY_ANIM,false)
    end
    local showId=skillData.ShowId
    local time_key = math.floor(showId).."-"..math.floor(doubleHit)
    coroutine.start(function ()

        local timeLine= nil
        if self.timeLines ~= nil then
            timeLine = self.timeLines[time_key]
        end
        if timeLine == nil then
            AddNewSkillTime(self,skillData)
            if self.timeLines ~= nil then
                timeLine = self.timeLines[time_key]
            end
        end
        if timeLine==nil then
            Logger.LogError("查找timeline失败  使用技能timeLine Id  "..math.ceil(skillId).."-"..math.ceil(doubleHit)
                    .."  角色id  "..self.entity.entityId)
            self:OnSomeOneFinishSkill(1)
            UseNextAction(self)
        else
            --检测timeline是否都存在  不存在移除
            local function AddTimeLineInGroup(list,timeLineData)
                if timeLineData ~= nil then
                    if timeLineData.res ~= nil then
                        table.insert(list,timeLineData)
                    elseif timeLineData.path ~= nil then
                        timeLineData.res = ResourcesManager:GetInstance():CoLoadAsync(timeLineData.path,typeof(CS.UnityEngine.Timeline.TimelineAsset))
                        if timeLineData.res == nil then
                            Logger.LogError("资源未查找到  ".. timeLineData.path)
                        else
                            table.insert(list,timeLineData)
                        end
                    end
                end
            end
            local replaceSim = nil
            if self.show_special_blood and simpleThreeBeat == 1 then
                replaceSim = self.timeLines[time_key.."_sim"]
            end
            self.timeLineGroup = {}
            for i = 1,#timeLine do
                if self.show_special_blood and simpleThreeBeat == 1 then
                    if timeLine[i].type == 2 then
                        AddTimeLineInGroup(self.timeLineGroup,replaceSim)
                    elseif timeLine[i].type == 1 then
                        AddTimeLineInGroup(self.timeLineGroup,timeLine[i])
                    end
                else
                    AddTimeLineInGroup(self.timeLineGroup,timeLine[i])
                end
            end
            if #self.timeLineGroup > 0 then
                self.timeLineIndex = 1
                local position=self.transform.position
                local data={roleView=self,pos={position.x,position.y+GetBloodOffet(self),position.z},skillId= skillId}
                self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.SOMEONE_START_SKILL,data)
                self.totalHurt = 0
                self.hideTotalHurt = 0
                PlaySkillTimeLine(self)
                self:ChangeState(BattleEnum.BattleRoleState.USE_SKILL)
                --播放镜头动画
                if isGuaidSkill and timeLine[1].type == 1 then
                    local isEnemy = self.entity.playerType==BattleEnum.BattlePlayerType.ENEMY
                    if isEnemy then
                        self.viewContext.battleCameraManager:SkillCloserRole(self.transform.parent.parent.localPosition+Vector3.New(7,4,-5.56),timeLine[1].time)
                    else
                        self.viewContext.battleCameraManager:SkillCloserRole(self.transform.parent.parent.localPosition+Vector3.New(7,4,-5.56),timeLine[1].time)
                    end
                end
            else
                Logger.LogError("资源最终未找到  列表为0")
                self:OnSomeOneFinishSkill(1)
                UseNextAction(self)
            end
        end
    end)
end

local function UseSkill(self,skillId,doubleHit,skillCases,isGuaidSkill,isLastSkill,returnType,intervener,simpleThreeBeat)
    --1、主目标  其他目标   死亡的角色  所有涉及到的角色
    --2、修正距离
    --3、读取timeline并播放
    self.actionType = 1
    self.skillCases = skillCases
    self.mainTarget=nil
    self.otherTargets={}
    self.skillTargetsView = {}
    self.relRoleIds = {}
    self.deadTargets = {}
    self.attackOffset=0
    self.isLastSkill = isLastSkill
    self.returnType = returnType
    local selectRole = {}
    for m, n in ipairs(skillCases) do
        for k,v in ipairs(n) do
            local roleView=self.viewContext.battleRoleViewManager:GetRoleViewById(v.teamId,v.entityId)
            if not selectRole[roleView] then
                self.relRoleIds[v.entityId] = v.teamId
                if k==1 then
                    self.mainTarget=roleView
                else
                    if roleView ~= self then
                        table.insert(self.otherTargets,roleView.gameObject)
                    end
                end
                --自身不能加入进去
                if roleView ~= self then
                    table.insert(self.skillTargetsView,roleView)
                end
                selectRole[roleView] = true
            end
            --血量不能去重
            if v.blood.finalHp <= 0 then
                roleView.viewDead = true
                self.deadTargets[roleView.gameObject.name] = true
            end
        end
    end
    --援护代码
    local interveneRole = nil
    if intervener ~= nil and intervener > 0 then
        local roleView=self.viewContext.battleRoleViewManager:GetRoleViewById(self.mainTarget.entity.teamId,intervener)
        if roleView ~= nil  then
            interveneRole = roleView
        end
    end
    if interveneRole ~= nil then
        self.intervene = true
        local targetPos = interveneRole.transform.position + interveneRole.transform.forward * 1.3
        self.oldIntervenePos = self.mainTarget.transform.parent.parent.position
        self.lastIntervene = self.mainTarget
        if self.deadTargets[self.mainTarget.gameObject.name] then
            self.mainTargetDead = true
        else
            self.mainTargetDead = false
        end
        self.mainTarget:Play("exskill_2")
        LuaTweener.TransMoveTo(self.lastIntervene.transform,self.oldIntervenePos,targetPos,0.5,EaseFormula.Linear,function()
            ReadyPlayTimeline(self,skillId,doubleHit,isGuaidSkill,simpleThreeBeat)
        end)
    else
        self.intervene = false
        ReadyPlayTimeline(self,skillId,doubleHit,isGuaidSkill,simpleThreeBeat)
    end
end

local function CallGuardian(self,targetRole,simpleThreeBeat,callTargets)
    --1、涉及到的角色
    --2、读取召唤timeline
    self.callTarget = self.viewContext.battleRoleViewManager:GetRoleViewById(targetRole.teamId,targetRole.entityId)
    self.relRoleIds = {[targetRole.entityId] = targetRole.teamId,[self.entity.entityId] = self.entity.teamId}
    self.actionType = 0
    self.isExclusiveCall = BattleAssistFunction.CheckIsExclusiveCall(self.entity.playerType,self.entity.entityId,targetRole.entityId)
    self.otherTargets = {}
    self.skillTargetsView = {}
    self.deadTargets = {}
    for i, v in ipairs(callTargets) do
        if v.teamId ~= self.entity.teamId and v.entityId ~= self.entity.entityId then
            local actRole =  self.viewContext.battleRoleViewManager:GetRoleViewById(v.teamId,v.entityId)
            table.insert(self.otherTargets,actRole.gameObject)
            table.insert(self.skillTargetsView,actRole)
            --血量不能去重
            if v.blood ~= nil and v.blood.finalHp <= 0 then
                actRole.viewDead = true
                self.deadTargets[actRole.gameObject.name] = true
            end
        end
    end
    coroutine.start(function ()
        local color=self.entity.callSkill.crytalType
        self.AppearPrefabPath=""
        self.DownPrefabPath=""
        self.AppearPrefabObj=nil
        self.DownPrefabObj=nil
        if color==1 then--消耗红色水晶，用红色特效
            self.AppearPrefabPath="Art/EffectRes/Common/FX_c_other_zhaohuan_hero appear_R.prefab"
            self.DownPrefabPath="Art/EffectRes/Common/FX_c_other_zhaohuan_hero down_R.prefab"
        elseif color==3 then--消耗蓝色水晶，用蓝色特效
            self.AppearPrefabPath="Art/EffectRes/Common/FX_c_other_zhaohuan_hero appear_B.prefab"
            self.DownPrefabPath="Art/EffectRes/Common/FX_c_other_zhaohuan_hero down_B.prefab"
        else -- color==2 then--消耗黄色水晶 和 "默认" 使用黄色特效
            self.AppearPrefabPath="Art/EffectRes/Common/FX_c_other_zhaohuan_hero appear.prefab"
            self.DownPrefabPath="Art/EffectRes/Common/FX_c_other_zhaohuan_hero down.prefab"

        end
        local followAnchor=-1
        local lookAtAnchor = -1
        local camFollowAttacker = false
        local lookAttAttacker=false
        local isEnemy = self.entity.playerType==BattleEnum.BattlePlayerType.ENEMY
        self.AppearPrefabObj=GameObjectPool:GetInstance():CoGetGameObjectAsync(self.AppearPrefabPath)
        if self.AppearPrefabObj~=nil then
            self.AppearPrefabObj:SetActive(false)
        else
            Logger.LogError("No Appera Fx:" .. self.AppearPrefabPath .. " -- Color:" .. color)
        end
        self.DownPrefabObj=GameObjectPool:GetInstance():CoGetGameObjectAsync(self.DownPrefabPath)
        if self.DownPrefabObj~=nil then
            self.DownPrefabObj:SetActive(false)
        else
            Logger.LogError("No Down Fx:" .. self.DownPrefabPath .. " -- Color:" .. color)
        end

        self.playAbleDirector.timeUpdateMode = CS.UnityEngine.Playables.DirectorUpdateMode.GameTime
        --播放预备tieline
        local preTimeLine = self.guardianTimeLine.pre
        if preTimeLine ~= nil then
            if preTimeLine.res == nil then
                preTimeLine.res =  ResourcesManager:GetInstance():CoLoadAsync(preTimeLine.path,typeof(CS.UnityEngine.Timeline.TimelineAsset))
            end
            if preTimeLine.res ~= nil then
                self.playAbleDirector.playableAsset = preTimeLine.res
                CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.BindingRoles(
                        self.playAbleDirector,
                        self.gameObject,nil,nil,
                        self.viewContext.battleCameraManager.camera.gameObject,
                        self.skillVCam,
                        self.commonVCamGroup0,nil,
                        false,camFollowAttacker,
                        followAnchor,
                        lookAttAttacker,
                        lookAtAnchor,
                        0,0)
                self.playAbleDirector:Play()
                --播放相机镜头
                LJAudioManger:GetInstance():PlayVoice("UI_Camera_07")
                if isEnemy then
                    self.viewContext.battleCameraManager:SkillCloserRole(self.transform.parent.parent.localPosition+Vector3.New(7,4,-5.56),preTimeLine.time)
                else
                    self.viewContext.battleCameraManager:SkillCloserRole(self.transform.parent.parent.localPosition+Vector3.New(7,4,-5.56),preTimeLine.time)
                end

                coroutine.waitforseconds(preTimeLine.time)
            end
            --self.playAbleDirector:Stop()
        end
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.UpdateRoleRender(self.gameObject,self.callTarget.gameObject,nil,1)
        self.viewContext.battleCameraManager:CameraMaskAction(1,0,function()
            self.viewContext.battleRoleViewManager:MoveNoBattleRole(self.relRoleIds)
            --隐藏特效
            ShowOrHideEffect(self,false)
        end)
        --简化版本召唤
        if simpleThreeBeat == 1 and self.guardianTimeLine.simPath ~= nil then
            if self.guardianTimeLine.sim == nil then
                self.guardianTimeLine.sim = ResourcesManager:GetInstance():CoLoadAsync(self.guardianTimeLine.simPath,typeof(CS.UnityEngine.Timeline.TimelineAsset))
            end
            self.skillEvent = CreateEvent(self.guardianTimeLine.simEvent)
            self.actionUseTime = self.guardianTimeLine.simTime
            self.playAbleDirector.playableAsset = self.guardianTimeLine.sim
        else
            if isEnemy then
                if self.guardianTimeLine.other == nil then
                    self.guardianTimeLine.other = ResourcesManager:GetInstance():CoLoadAsync(self.guardianTimeLine.otherPath,typeof(CS.UnityEngine.Timeline.TimelineAsset))
                end
                --如果没有敌方  查找己方
                if self.guardianTimeLine.other == nil then
                    self.guardianTimeLine.other = ResourcesManager:GetInstance():CoLoadAsync(self.guardianTimeLine.mainPath,typeof(CS.UnityEngine.Timeline.TimelineAsset))
                    --event事件随之改变
                    self.guardianTimeLine.otherEvent = self.guardianTimeLine.mainEvent
                    self.guardianTimeLine.otherTime = self.guardianTimeLine.mainTime
                end
                self.skillEvent = CreateEvent(self.guardianTimeLine.otherEvent)
                self.actionUseTime = self.guardianTimeLine.otherTime
                self.playAbleDirector.playableAsset = self.guardianTimeLine.other
            else
                if self.guardianTimeLine.main == nil then
                    self.guardianTimeLine.main = ResourcesManager:GetInstance():CoLoadAsync(self.guardianTimeLine.mainPath,typeof(CS.UnityEngine.Timeline.TimelineAsset))
                end
                self.skillEvent = CreateEvent(self.guardianTimeLine.mainEvent)
                self.actionUseTime = self.guardianTimeLine.mainTime
                self.playAbleDirector.playableAsset = self.guardianTimeLine.main
            end
        end


        local downFx = nil
        if not isEnemy then
            downFx = self.DownPrefabObj
        end
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.BindingRoles_SummonAction(
                self.AppearPrefabObj,
                downFx,
                self.playAbleDirector,
                self.gameObject,self.callTarget.gameObject,self.otherTargets,
                self.viewContext.battleCameraManager.camera.gameObject,
                self.skillVCam,
                self.commonVCamGroup0,nil,
                false,camFollowAttacker,
                followAnchor,
                lookAttAttacker,
                lookAtAnchor,
                0,0)

        --如果是敌方,使用敌方召唤相机
        local camAnimPath
        if isEnemy then
            camAnimPath = "Art/Roles/common/summon_camanim_Enemy.anim"
        else
            camAnimPath = "Art/Roles/common/summon_camanim.anim"
        end
        local camAnimClip = ResourcesManager:GetInstance():CoLoadAsync( camAnimPath,typeof(CS.UnityEngine.AnimationClip))
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.ReplaceSkillCameraAnim(
                self.playAbleDirector,
                camAnimClip
        )
        self.playAbleDirector:Play()
        self:ChangeState(BattleEnum.BattleRoleState.USE_SKILL)
    end)

end


local function PlayWin(self)
    --停止2倍速音效
    LJAudioManger:GetInstance():PlayVoice("Time_x0")

    self.playAbleDirector.playableAsset=self.winTimeLine
    self.playAbleDirector.extrapolationMode=CS.UnityEngine.Playables.DirectorWrapMode.Hold
    --set role lit
    local litTran = nil
    --find role lit
    local lights = CS.UnityEngine.Light.GetLights(
            CS.UnityEngine.LightType.Directional
    , CS.UnityEngine.LayerMask.NameToLayer("Charactor")
    )

    for i = 0, lights.Length - 1 do
        if lights[i].gameObject.activeInHierarchy then
            litTran = lights[i].transform
            break
        end
    end
    if not IsNull(litTran) then
        local oldP = litTran.parent
        litTran:SetParent(self.transform)
        litTran.localPosition =   Vector3.New(0,3,0)
        litTran.localEulerAngles = Vector3.New(35,-221.5,75)
        litTran:SetParent(oldP)
    end


    --self.viewContext.battleCameraManager.camera.transform:SetParent(self.transform)
    --new skill camera logic
    --edit by Zhangshoufeng
    local followAnchor=-1
    local lookAtAnchor = -1
    local camFollowAttacker = false
    local lookAttAttacker=false
    CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.BindingRoles(
            self.playAbleDirector,
            self.gameObject,nil,nil,
            self.viewContext.battleCameraManager.camera.gameObject,
            self.skillVCam,
            self.commonVCamGroup0,nil,
            false,camFollowAttacker,
            followAnchor,
            lookAttAttacker,
            lookAtAnchor,
            0,0)

    --self.playAbleDirector:stopped('+',playEnd)
    self.playAbleDirector:Play()
    self.playTimeResult = false
    self.actionUseTime = self.winTimeLine_time.time
    self.skillEvent = CreateEvent(self.winTimeLine_time.event)
    self:ClearBuff()
    self:ChangeState(BattleEnum.BattleRoleState.WIN)
end

local function ChangeState(self,state)
    --Logger.Log("显示层角色改变状态 "..tostring(self.entity.entityId).." state "..tostring(state))
    self.currentState=state
    self.timer=Time.time
    if self.currentState==BattleEnum.BattleRoleState.ENTER then
        self:Play(BattleRoleView.AnimName_Name_Login)
    elseif self.currentState==BattleEnum.BattleRoleState.IDLE then
        --待机归位
        if self.entity.hp > 0 then
            self:Play(BattleRoleView.AnimName_Name_Idle)
        end
    elseif self.currentState==BattleEnum.BattleRoleState.USE_SKILL then

    elseif self.currentState==BattleEnum.BattleRoleState.DEAD then
        if self.lastDeadRole then
            self:Play(BattleRoleView.AnimName_Name_Die)
        else
            self:Play(BattleRoleView.AnimName_Name_Die2)
        end
        if not self.entity:CheckIsMainRole() then
            self.viewContext:BlockAction(true)
        end
    elseif self.currentState==BattleEnum.BattleRoleState.DESTROY then
        --如果是守护灵
        if not self.entity:CheckIsMainRole() then
            local mainRole = self.entity.group.mainRole
            local mainView=self.viewContext.battleRoleViewManager:GetRoleViewById(mainRole.teamId,mainRole.entityId)
            if mainView.currentState == BattleEnum.BattleRoleState.USE_SKILL then
                self.viewContext:CallGuardDead(mainView)
            else
                mainView:ChangeBattlePosition(BattleEnum.BattlePosition.FRONT)
                mainView:ChangeParent()
                mainView:ChangeState(BattleEnum.BattleRoleState.CHANGEPOSITION)
            end
            self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYROUNDDATASWITCH,{old = self.entity.entityId,new = mainRole})
        end
        self.destroyTween = LuaTweener.TransMoveTo(self.transform,self.transform.position,self.transform.position-Vector3.up*0.3,2,EaseFormula.InCubic,function()
            self.destroyTween = nil
        end)
        self.fxController:StartDissEffect(2)
    elseif self.currentState==BattleEnum.BattleRoleState.CHANGEPOSITION then
        self:Play(BattleRoleView.AnimName_Name_Login)
    end
end

local function Update(self)
    for i=table.count(self.effectViews),1,-1 do
        self.effectViews[i]:Update()
    end
    if IsNull(self.animator) then
        return
    end
    if self.currentState==BattleEnum.BattleRoleState.ENTER then

    elseif self.currentState==BattleEnum.BattleRoleState.IDLE then

    elseif self.currentState==BattleEnum.BattleRoleState.USE_SKILL then
        local curTime = Time.time - self.timer
        if self.skillEvent ~= nil then
            for i = #self.skillEvent, 1,-1 do
                if curTime >= self.skillEvent[i].time then
                    SkillCaseHandler(self,self.skillEvent[i].msg,self.skillEvent[i].lParam,self.skillEvent[i].fParam,self.skillEvent[i].sParam,self.skillEvent[i].isLast,self.skillEvent[i].aParam)
                    if self.skillEvent == nil then
                        break
                    else
                        table.remove(self.skillEvent,i)
                    end
                end
            end
        end
        if self.actionType == 1 and self.useSkillState == 1 and curTime > self.actionUseTime - 0.3 then
            self.viewContext.battleCameraManager:CameraMaskAction(0,1)
            self.useSkillState = 0
        end
        if curTime > self.actionUseTime then
            if self.actionType == 0 then
                self:OnSomeOneFinishSkill(2)
                self:ChangeState(BattleEnum.BattleRoleState.IDLE)
                self.viewContext:SomeoneSkillOver()
            elseif self.actionType == 1 then
                PlaySkillTimeLine(self)
            end
        end
    elseif self.currentState==BattleEnum.BattleRoleState.DEAD then
        local curTime = Time.time - self.timer
        if curTime > 3 then
            self:ChangeState(BattleEnum.BattleRoleState.DESTROY)
        else
            local animName = BattleRoleView.AnimName_Name_Die2
            if self.lastDeadRole then
                animName = BattleRoleView.AnimName_Name_Die
            end
            if CheckAnimState(self,animName) >= 1 then
                self:ChangeState(BattleEnum.BattleRoleState.DESTROY)
            end
        end
    elseif self.currentState==BattleEnum.BattleRoleState.DESTROY then
        local curTime = Time.time - self.timer
        if curTime > 2 then --判断当前状态  如果是使用技能或者召唤  先不要死
            self:OnDestroy()
        end
    elseif self.currentState==BattleEnum.BattleRoleState.CHANGEPOSITION then
        local curTime = Time.time - self.timer
        if curTime > 2 then
            self:ChangeState(BattleEnum.BattleRoleState.IDLE)
            self.viewContext:BlockAction(false)
        else
            if CheckAnimState(self,BattleRoleView.AnimName_Name_Login) >= 1 then
                self:ChangeState(BattleEnum.BattleRoleState.IDLE)
                self.viewContext:BlockAction(false)
            end
        end
    elseif self.currentState==BattleEnum.BattleRoleState.WIN then
        local curTime = Time.time - self.timer
        if self.skillEvent ~= nil then
            for i = #self.skillEvent, 1,-1 do
                if curTime >= self.skillEvent[i].time then
                    SkillCaseHandler(self,self.skillEvent[i].msg,self.skillEvent[i].lParam,self.skillEvent[i].fParam,self.skillEvent[i].sParam,self.skillEvent[i].isLast,self.skillEvent[i].aParam)
                    table.remove(self.skillEvent,i)
                end
            end
        end
        if curTime > self.actionUseTime and not self.playTimeResult then
            self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUIRESULT,self.viewContext.settlement)
            self.playTimeResult = true
        end
    end

end

local function OpreateHp(self,hpChange,isCrit,hurtType,tHurt,tHide)
    --发送UI血量冒字
    local type=0
    if hpChange<0 then
        type=1
    else
        type=2
    end
    local position=self.transform.position

    local data={pos={position.x,position.y+GetBloodOffet(self),position.z},num=hpChange,type=type,isCrit=isCrit,hurtType=hurtType,playerType = self.entity.playerType,totalHurt = tHurt,totalHide = tHide}

    self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUICHANGEHP,data)
end

local function ClearBuff(self)
    for i=table.count(self.effectViews),1,-1 do
        self.effectViews[i]:OnDestroy()
    end
    self.hideEffectViews = {}
end

local function OnDestroy(self)
    self:ForceEndSkill()
    self.fxController:ResetDissEffect()
    self.winTimeLine=nil
    self.guardianTimeLine=nil
    self.guardianPreTimeLine = nil
    --如果当前类型是使用技能阶段
    --if self.currentState==BattleEnum.BattleRoleState.USE_SKILL then
    --    if self.actionType == 0 then
    --        self.viewContext.battleCameraManager:CameraMaskAction(-1)
    --    else
    --        if self.show_special_blood then
    --            self.viewContext.battleCameraManager:CameraBackgroudMask(-1)
    --        end
    --    end
    --end
    ClearBuff(self)
    if self.timeLines ~= nil then
        for k,v in pairs(self.timeLines) do
            v=nil
        end
    end
    if self.AppearPrefabObj~=nil then
        GameObjectPool:GetInstance():RecycleGameObject(self.AppearPrefabPath,self.AppearPrefabObj.gameObject)
        self.AppearPrefabObj = nil
        self.AppearPrefabPath = nil
    end
    if self.DownPrefabObj~=nil then
        GameObjectPool:GetInstance():RecycleGameObject(self.DownPrefabPath,self.DownPrefabObj.gameObject)
        self.DownPrefabObj = nil
        self.DownPrefabPath = nil
    end
    CS.UnityEngine.GameObject.Destroy(self.commonVCamGroup0)
    CS.UnityEngine.GameObject.Destroy(self.commonVCamGroup1)
    table.removebyvalue(self.viewContext.battleRoleViewManager.roles,self)
    GameObjectPool:GetInstance():RecycleGameObject(self.path,self.gameObject)
    HideChooseSkillEffect(self)
    if self.skillTimeLineTimer ~= nil then
        TimerManager:GetInstance():SimpleTimerStop(self.skillTimeLineTimer)
    end
    if not IsNull(self.skillVCam) then
        CS.UnityEngine.GameObject.Destroy(self.skillVCam)
    end
    if self.destroyTween ~= nil then
        LuaTweener.StopTweener(self.destroyTween)
        self.destroyTween = nil
    end
    if self.battle_direction_effect ~= nil then
        GameObjectPool:GetInstance():RecycleGameObject(battle_direction_path,self.battle_direction_effect)
        self.battle_direction_effect = nil
    end
    local beginPath = self.entity:CheckIsMainRole() and power_blue_JLR_begin or power_blue_SHL_begin;
    local endPath = self.entity:CheckIsMainRole() and power_blue_JLR_end or power_blue_SHL_end;
    if self.power_begin_effect ~= nil then
        GameObjectPool:GetInstance():RecycleGameObject(beginPath,self.power_begin_effect)
        self.power_begin_effect = nil
    end
    if self.power_end_effect ~= nil then
        GameObjectPool:GetInstance():RecycleGameObject(endPath,self.power_end_effect)
        self.power_end_effect = nil
    end
end


local function AddEffectView(self,effectView)
    table.insert(self.effectViews,effectView)
end
local function GetEffectViewById(self,effectId)
    for k,v in pairs(self.effectViews) do
        if v ~=nil and v.effectId==effectId then
            return v
        end
    end
    return nil
end
--强制结束技能
local function ForceEndSkill(self)
    if self.currentState==BattleEnum.BattleRoleState.USE_SKILL then
        if self.actionType == 0 then
            self.playAbleDirector:Stop()
            self:OnSomeOneFinishSkill(2)
        elseif self.actionType == 1 then
            --援护目标归位
            if self.intervene then
                if self.interveneTween ~= nil then
                    LuaTweener.StopTweener(self.interveneTween)
                    self.interveneTween = nil
                end
                self.lastIntervene.transform.position = self.oldIntervenePos
                self.intervene = false
            end
            --施法者目标归位
            if self.origeParentFor ~= nil then
                self.transform.parent.parent.forward = self.origeParentFor
            end
            self.transform.parent.localPosition = Vector3.zero
            self.transform.parent.localEulerAngles = Vector3.zero
            self.playAbleDirector:Stop()
            self:OnSomeOneFinishSkill(1)
        end
        self:ChangeState(BattleEnum.BattleRoleState.IDLE)
    end
end
--技能播放完重置
local function SkillPlayOverReset(self)
    if self.currentState==BattleEnum.BattleRoleState.IDLE  and self.battlePosition==BattleEnum.BattlePosition.FRONT then
        if self.entity.hp > 0 then
            if not self.gameObject.activeSelf then
                self.gameObject:SetActive(true)
            end
            self.transform.parent.localPosition = Vector3.zero
            self.transform.parent.localEulerAngles = Vector3.zero
        end
    elseif self.currentState == BattleEnum.BattleRoleState.BE_HIT then
        if self.entity.hp > 0 then
            ChangeState(self,BattleEnum.BattleRoleState.IDLE)
            if not self.gameObject.activeSelf then
                self.gameObject:SetActive(true)
            end
            self.transform.parent.localPosition = Vector3.zero
            self.transform.parent.localEulerAngles = Vector3.zero
        end
    end
end

local function OnSomeOneFinishSkill(self,type)
    --技能释放完切换相机
    self.viewContext.battleCameraManager:ChangeCtrlCam(3,0)
    if type == 1 then
        local mainGame = nil
        if self.mainTarget ~= nil then
            mainGame = self.mainTarget.gameObject
        end
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.UpdateRoleRender(self.gameObject,mainGame,self.otherTargets,0)
        --self.viewContext.battleRoleViewManager:ResetBattleRole(self.relRoleIds)
        if self.show_special_blood then
            UIManager:GetInstance():Broadcast(UIMessageNames.UIBATTLE_PLAY_CRY_ANIM,true)
            self.viewContext.battleRoleViewManager:ResetMoveBattleRole(self.relRoleIds)
            self.viewContext.battleCameraManager:CameraBackgroudMask(-1)
            --显示出来三连击隐藏的特效
            for m,skillCase in ipairs(self.skillCases) do
                if skillCase~=nil  then
                    for k,v in ipairs(skillCase) do
                        local view=self.viewContext.battleRoleViewManager:GetRoleViewById(v.teamId,v.entityId)
                        if view ~= nil and view.entity.hp > 0 then
                            view:SpecialSkillShowEffect()
                        end
                    end
                end
            end
        else
            self.viewContext.battleCameraManager:CameraMaskAction(-1)
        end
        HandleBloodFunc(self,1)
        self.skillCases = nil
        self.mainTarget = nil
        self.otherTargets = nil
        self.relRoleIds = nil
        self.deadTargets = nil
        self.skillTargetsView = nil
    elseif type == 2 then
        self:ChangeBattlePosition(BattleEnum.BattlePosition.BACK)
        ChangeParent(self)
        self.viewContext.battleRoleViewManager:ResetMoveBattleRole(self.relRoleIds)
        self.viewContext.battleCameraManager:CameraMaskAction(-1)
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.UpdateRoleRender(self.gameObject,self.callTarget.gameObject,nil,0)
        self.callTarget = nil
        self.skillEvent = nil
        self.otherTargets = nil
        self.deadTargets = nil
        self.skillTargetsView = nil
        if self.AppearPrefabObj~=nil then
            GameObjectPool:GetInstance():RecycleGameObject(self.AppearPrefabPath,self.AppearPrefabObj.gameObject)
            self.AppearPrefabObj = nil
            self.AppearPrefabPath = nil
        end
        if self.DownPrefabObj~=nil then
            GameObjectPool:GetInstance():RecycleGameObject(self.DownPrefabPath,self.DownPrefabObj.gameObject)
            self.DownPrefabObj = nil
            self.DownPrefabPath = nil
        end
    end
end
--改变前后排位置
local function ChangeBattlePosition(self,pos)
    self.battlePosition=pos
end
--检测显示层是否死亡
local function CheckDead(self)
    if self.viewDead and self.currentState<BattleEnum.BattleRoleState.DEAD then
        self:ChangeState(BattleEnum.BattleRoleState.DEAD)
    end
end
--强制死亡
local function ForceDead(self)
    self.viewDead = true
    if self.currentState<BattleEnum.BattleRoleState.DEAD then
        self:ChangeState(BattleEnum.BattleRoleState.DEAD)
    end
end
--被击状态
local function BeHitState(self,animName,fade,start)
    --只有前排才有被击
    if not self.viewDead and self.currentState<BattleEnum.BattleRoleState.DEAD and self.battlePosition==BattleEnum.BattlePosition.FRONT then
        Play(self,animName,fade,start)
        ChangeState(self,BattleEnum.BattleRoleState.BE_HIT)
    end
end

--显示技能提示字
local function ShowEffectName(self, effect)
    if effect.type == 5 then
        self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYEFFECTTIP,{self.transform.position.x,self.transform.position.y+GetBloodOffet(self),self.transform.position.z},"驱散")
    elseif effect.hurtType == 5 then
        self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYEFFECTTIP,{self.transform.position.x,self.transform.position.y+GetBloodOffet(self),self.transform.position.z},"吸收")
    elseif effect.hurtType == 6 then
        self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYEFFECTTIP,{self.transform.position.x,self.transform.position.y+GetBloodOffet(self),self.transform.position.z},"免疫")
    end
end

--显示召唤守护灵落地特效
local function ShowCallDownEffect(self)
    if self.roleConfig.guarDianFx ~= nil then
        local fxConfig=DataUtil.GetData("fx_config")[self.roleConfig.guarDianFx]
        if fxConfig.prefab_Name ~= nil or #fxConfig.prefab_Name > 0 then
            AddNewEffect(self,0,fxConfig,0,0,false)
        end
    end
end

--显示脚下的朝向
local function ShowDirectionEffect(self, isShow, fowardPos)
    local _tarDir = (fowardPos - self.transform.position).normalized
    if self.battle_direction_effect == nil then
        GameObjectPool:GetInstance():GetGameObjectAsync(battle_direction_path,function(go)
            if not IsNull(go) then
                --go.transform:SetParent(self.transform)
                self.battle_direction_effect = go
                self.battle_direction_effect.transform.position = self.transform.position
                self.battle_direction_effect.transform.forward = _tarDir
                self.battle_direction_effect.gameObject:SetActive(isShow)
            end
        end)
    else
        self.battle_direction_effect.transform.forward = _tarDir
        self.battle_direction_effect.gameObject:SetActive(isShow)
    end
end

--显示水晶满之后的特效
local function ShowPowerEffect(self, isShow)
    local beginPath = self.entity:CheckIsMainRole() and power_blue_JLR_begin or power_blue_SHL_begin;
    local endPath = self.entity:CheckIsMainRole() and power_blue_JLR_end or power_blue_SHL_end;
    if self.power_end_effect ~= nil then
        GameObjectPool:GetInstance():RecycleGameObject(endPath,self.power_end_effect)
        self.power_end_effect = nil
    end
    if isShow then
        if self.power_begin_effect == nil then
            GameObjectPool:GetInstance():GetGameObjectAsync(beginPath,function(go)
                if not IsNull(go) then
                    go.transform:SetParent(self.transform)
                    self.power_begin_effect = go
                    self.power_begin_effect.transform.localPosition = Vector3.New(0, 0, 0)
                end
            end)
        end
    elseif self.power_begin_effect ~= nil then
        if self.power_begin_effect ~= nil then
            GameObjectPool:GetInstance():RecycleGameObject(beginPath,self.power_begin_effect)
            self.power_begin_effect = nil
        end
        GameObjectPool:GetInstance():GetGameObjectAsync(endPath,function(go)
            if not IsNull(go) then
                go.transform:SetParent(self.transform)
                self.power_end_effect = go
                self.power_end_effect.transform.localPosition = Vector3.New(0, 0, 0)
            end
        end)
    elseif self.power_end_effect ~= nil then
        GameObjectPool:GetInstance():RecycleGameObject(endPath,self.power_end_effect)
        self.power_end_effect = nil
    end
end

--显示边缘光
local function ShowEdgeLight(self, isShow)
    local cry_type,cry_max,cry_num,cry_init_max = self.entity:GetCryCost()
    local color = Color.New(1, 0, 0, 1)
    if cry_type == 2 then
        color = Color.New(1, 1, 0, 1)
    elseif cry_type == 3 then
        color = Color.New(0, 0, 1, 1)
    end
    self.fxController:SetEdgeLit(isShow, color, 1.5);
end

BattleRoleView.__init=__init
BattleRoleView.OnInit=OnInit
BattleRoleView.CheckDead = CheckDead
BattleRoleView.ForceDead = ForceDead
BattleRoleView.BeHitState = BeHitState
BattleRoleView.SkillPlayOverReset = SkillPlayOverReset
BattleRoleView.ForceEndSkill = ForceEndSkill
BattleRoleView.ChangeBattlePosition = ChangeBattlePosition
BattleRoleView.Update=Update
BattleRoleView.OnDestroy=OnDestroy
BattleRoleView.Play=Play
BattleRoleView.ChangeState=ChangeState
BattleRoleView.FillTimeLines=FillTimeLines
BattleRoleView.SetGuardianTimeLine=SetGuardianTimeLine
BattleRoleView.UseSkill=UseSkill
BattleRoleView.CallGuardian=CallGuardian
BattleRoleView.ChangeParent=ChangeParent
BattleRoleView.OpreateHp=OpreateHp
BattleRoleView.OnSomeOneBloodShow=OnSomeOneBloodShow
BattleRoleView.SetWinTimeLine=SetWinTimeLine
BattleRoleView.PlayWin=PlayWin
BattleRoleView.GetEffectViewById=GetEffectViewById
BattleRoleView.PlaySkillEffect = PlaySkillEffect
BattleRoleView.AddEffectView=AddEffectView
BattleRoleView.GetBloodData = GetBloodData
BattleRoleView.OnSomeOneFinishSkill = OnSomeOneFinishSkill
BattleRoleView.ClearBuff = ClearBuff
BattleRoleView.PlayChooseSkillEffect = PlayChooseSkillEffect
BattleRoleView.SimpleHandleSkil = SimpleHandleSkil
BattleRoleView.SpecialSkillShowEffect = SpecialSkillShowEffect
BattleRoleView.ShowEffectName = ShowEffectName
BattleRoleView.ShowCallDownEffect = ShowCallDownEffect
BattleRoleView.ShowDirectionEffect = ShowDirectionEffect
BattleRoleView.ShowPowerEffect = ShowPowerEffect
BattleRoleView.ShowEdgeLight = ShowEdgeLight
return BattleRoleView