---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by guoyu.
--- DateTime: 2018/12/21 10:10
---
local BattleRoleView=BaseClass("BattleRoleView")
BattleRoleView.AnimName_Name_Login="login"
BattleRoleView.AnimName_Name_Idle="idle"
BattleRoleView.AnimName_Name_Idle2="idle_2"
BattleRoleView.AnimName_Name_Die="die"
BattleRoleView.AnimName_Name_Die2="hit_3"

local BattleAssistFunction= require "GameLogic.BattleNew.BattleAssistFunction"
local BattleConstConfig = require "GameLogic.BattleNew.BattleConstConfig"
local BattleSkillEffectViewFactory=require"GameLogic.BattleNew.View.BattleSkillEffectViewFactory"
local choose_effect_path = "Art/EffectRes/Common/FX_c_pre fight.prefab"
local function __init(self)
    --表现层上下文
    self.viewContext=nil
    --逻辑控制
    self.entity=nil
    --GameObject
    self.gameObject=nil
    --Transform
    self.transform=nil
    --Animator
    self.animator=nil
    --playAbleDirector
    self.playAbleDirector=nil
    --死亡消融组件
    self.fxController=nil
    --前一个状态
    self.preState=nil
    --当前状态
    self.currentState=nil
    --技能timeLines
    self.timeLines=nil
    --召唤技能TimeLine
    self.guardianTimeLine=nil
    --预备timeline
    self.guardianPreTimeLine = nil
    --胜利庆祝TimeLine
    self.winTimeLine=nil

    --缓存路径
    self.path=nil
    --当前使用的技能信息
    self.currentSkillMessage=nil
    --当前召唤信息
    self.callSkillMessage = nil
    --self.skillCaseIndex=0

    --绑定的TIMELINE事件回调
    self.bindSkillCaseHandler=nil

    self.skillVCam=nil

    self.commonVCamGroup0=nil
    self.commonVCamGroup1=nil

    --技能效果特效
    self.effectViews={}
    --角色配置
    self.roleConfig=nil
    --是否是最后一个角色
    self.lastDeadRole = false
    --血量变化的单位
    self.blood_change = nil
    --是否显示血条
    self.blood_show = false
    --是否是连击技能
    self.show_special_blood = false
    self.useSkillState = 0
end
--清理保存的敌方血条
local function ClearSaveTargetBlood(self)
    if self.blood_change ~= nil and table.count(self.blood_change) > 0 then
        self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.SOMEONE_BLOOD_SHOW,self.blood_change,self.show_special_blood,1)
        self.blood_change = nil
    end
end

local function SkillCaseHandler(self,msg,param1,param2,param3)
    --Logger.Log(table.dump(self))
    local function ChangeBloodVal(cur_blood_change,change_val)
        change_val = math.abs(change_val)
        if cur_blood_change.curShield > 0 then
            if change_val > cur_blood_change.curShield then
                cur_blood_change.curShield = 0
                cur_blood_change.curhp = cur_blood_change.curhp - change_val+cur_blood_change.curShield
            else
                cur_blood_change.curShield = cur_blood_change.curShield - change_val
            end
        else
            cur_blood_change.curhp = cur_blood_change.curhp - change_val
        end
    end

    if msg=="hit" then
        --self.skillCaseIndex=self.skillCaseIndex+1
        if self.currentSkillMessage.cases ~= nil then
            local skillCase=self.currentSkillMessage.cases[param1]
            if skillCase~=nil  then
                for k,v in ipairs(skillCase.targets) do
                    local view=self.viewContext.battleRoleViewManager:GetRoleViewById(v.teamId,v.entityId)
                    local role=view.entity
                    local cur_blood_change = nil
                    if self.blood_change then
                        cur_blood_change = self.blood_change[role.entityId]
                    end

                    if self.entity.skill_case[param1]==true then
                        role:SyncByServerChange(v,param2,param3)
                        --当前减血
                        for j,z in ipairs(v.effects) do
                            if z.release~= nil then
                                if z.release.typeId==1 then
                                    if cur_blood_change ~= nil then
                                        ChangeBloodVal(cur_blood_change,Mathf.Ceil(z.release.hp*param2))
                                    end
                                    --添加闪白效果
                                    view.fxController:Flash(0.16)
                                end
                            end
                        end
                    else
                        --当前减血
                        for j,z in ipairs(v.effects) do
                            if z.release~= nil and z.release.typeId==1 then
                                role:OpreateHp(Mathf.Ceil(z.release.hp*param2),z.release.isCrit,z.release.hurtType)
                                if cur_blood_change ~= nil then
                                    ChangeBloodVal(cur_blood_change,Mathf.Ceil(z.release.hp*param2))
                                end
                                --添加闪白效果
                                view.fxController:Flash(0.16)
                            end
                        end
                    end
                    --检测下是否有加血和加护盾
                    if cur_blood_change ~= nil then
                        local shieldCur,shieldMax = role:GetShieldVal()
                        if cur_blood_change.curShield ~= shieldCur then
                            cur_blood_change.curShield = shieldCur
                            if shieldMax > 0 then
                                cur_blood_change.oldShieldMax = shieldMax
                            end
                        end
                    end
                    if v.hp <= 0 then
                        --判断是否是最后一个角色
                        local player=role.group.player
                        if player.playerType == BattleEnum.BattlePlayerType.ENEMY then
                            local liveRoleCount =player:GetLiveRoleCount()
                            if liveRoleCount<=0 then
                                view.lastDeadRole = true
                                if param3 ~= nil and #param3>0 then
                                    local timescale = string.split(param3,"#",1,true)
                                    self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.SOMEONE_HP_ZERO,role,tonumber(timescale[1]),tonumber(timescale[2]))
                                    self.viewContext:TriggerKillCam(role);
                                end
                            end
                        end
                    end

                end
                if self.blood_show then
                    if self.blood_change ~= nil and table.count(self.blood_change) > 0 then
                        self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.SOMEONE_BLOOD_SHOW,self.blood_change,self.show_special_blood)
                    end
                end

                self.entity:SyncFinishCase(param1)
            end
        else
            Logger.LogError("SkillCaseHandler hit event 错误  没有cases ")
        end

    elseif msg=="hideui" then
        --self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYHIDEUI)
    elseif msg=="cutin" then
        if self.entity.playerType==BattleEnum.BattlePlayerType.MINE then
            local showViewId =BattleAssistFunction.GetCardIdByTeamAndEntityId(self.entity.playerType,self.entity.entityId)
            self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUICUTIN,showViewId,param1)
        end
    elseif msg == "total_hit" then
        self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUIHIDETOTALHURT)
    elseif msg=="combo" then
        local data={entityId=self.entity.entityId,count=param1,teamId = self.entity.playerType}
        self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUICOMBO,data)
    elseif msg == "blood2" then
        if param1 == 1 then
            self.blood_show = true
            if self.blood_change ~= nil and table.count(self.blood_change) > 0 then
                self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.SOMEONE_BLOOD_SHOW,self.blood_change,self.show_special_blood)
            end
        else
            ClearSaveTargetBlood(self)
            self.blood_show = false
        end
    elseif msg == "forbid_rise" then
        local temp_agr =  string.split(param3,"_",1,true)
        local view=self.viewContext.battleRoleViewManager:GetRoleViewById(tonumber(temp_agr[1]),tonumber(temp_agr[2]))
        local role=view.entity
        role:SpecialDead()
    elseif msg == "result" then
        if not self.playTimeResult then
            self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYWINPLAYOVER)
            self.playTimeResult = true
        end
    elseif msg == "callcam" then
        LJAudioManger:GetInstance():PlayVoice("UI_Camera_08")
        self.viewContext.battleCameraManager:PveCallEndAnim()
    elseif msg=="callmask" then
        self.viewContext.battleCameraManager:CameraMaskAction(0,0)
        self.viewContext.battleRoleViewManager:ResetMoveBattleRole(self.relRoleIds)
    elseif msg == "3skillcam" then
        if param1 == 1 then
            --加载天空盒
            self.viewContext.battleCameraManager:CameraBackgroudMask(1)
            self.viewContext.battleRoleViewManager:MoveNoBattleRole(self.relRoleIds)
        else
            self.viewContext.battleCameraManager:CameraBackgroudMask(0)
        end
    end

end
--获取单位角色高度
local function GetBloodOffet(self)
    if self.roleConfig~= nil then
        return self.roleConfig.PrefabHeight*self.roleConfig.PrefabZoom
    else
        return 2
    end
end

local function OnInit(self,context,entity,gameObject,path)
    self.viewContext=context
    self.entity=entity
    self.gameObject=gameObject
    self.path=path
    self.transform=self.gameObject.transform
    self.animator=self.transform:GetComponentInChildren(typeof(CS.UnityEngine.Animator))
    self.playAbleDirector=self.transform:GetComponentInChildren(typeof(CS.UnityEngine.Playables.PlayableDirector))
    self.fxController=self.transform:GetComponentInChildren(typeof(CS.RoleFxController))
    self.effectViews={}
    local showViewId =BattleAssistFunction.GetCardIdByTeamAndEntityId(self.entity.playerType,self.entity.entityId)
    self.roleConfig = DataUtil.GetData("battle_role_config")[showViewId]
    self:ChangeParent()
    self.bindSkillCaseHandler=Bind(self,SkillCaseHandler)

    self.skillVCam=CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.GetSkillVCam();
    self.skillVCam.transform:SetParent(self.transform,false);

    self.transform.localScale=Vector3.New(self.roleConfig.PrefabZoom,self.roleConfig.PrefabZoom,self.roleConfig.PrefabZoom)
    --通知UI初始化血条
    local effects=self.entity.effects
    --获取所有的effectId
    local have_effect = {}
    for i=1,#self.effectViews do
        have_effect[self.effectViews[i].effectId] = true
    end
    for k,v in ipairs(effects) do
        --添加没有的特效
        if not have_effect[v.effectId] then
            local effectView= BattleSkillEffectViewFactory.CreateBattleSkillEffectView(self.viewContext,v,self)
            if effectView ~= nil then
                self:AddEffectView(effectView)
            end
        end
    end
end
--获取当前血条数据
local function GetBloodData(self,data)
    if self.entity.battlePosition==BattleEnum.BattlePosition.BACK then
        return {isShow = false,id=self.entity.entityId}
    elseif data == nil and self.entity.hp <= 0 then
        return {isShow = false,id=self.entity.entityId}
    end
    local effects=self.entity.effects
    local effectData={}
    for k,v in ipairs(effects) do
        if v.lastTime >0 then
            table.insert(effectData,{id=v.effectId,layer=v.layer,time=v.lastTime})
        end
    end
    local shieldVal = 0
    local shieldPer = 0
    local oldhp = 0
    local oldShield = 0
    local curhp = 0
    if data ~= nil then
        oldhp = data.oldhp/self.entity.maxHp
        curhp = data.curhp/self.entity.maxHp
        if data.oldShieldMax > 0 then
            oldShield = data.oldShield/data.oldShieldMax
            shieldVal = data.curShield/data.oldShieldMax
            shieldPer = data.oldShieldMax/self.entity.maxHp
            if shieldPer > 1 then
                shieldPer = 1
            end
        end
        data.oldhp = data.curhp
        data.oldShield = data.curShield
    else
        curhp = self.entity.currentHp
        oldhp = curhp
        local shieldCur,shieldMax = self.entity:GetShieldVal()
        if shieldMax > 0 then
            shieldVal = shieldCur/shieldMax
            oldShield = shieldVal
            shieldPer = shieldMax/self.entity.maxHp
            if shieldPer > 1 then
                shieldPer = 1
            end
        end
    end


    --local shieldVal,shieldPer = self.entity:GetShieldVal()
    return  {team=self.entity.playerType,transform=self.fxController:GetAnchorTrans(9),offset=GetBloodOffet(self),
             val=curhp,id=self.entity.entityId,effects=effectData,shieldPer = shieldPer,
             shieldVal = shieldVal,isShow=true,oldVal = oldhp,oldShield = oldShield}
end

local function GetSpecialBloodData(self,data)
    if self.entity.battlePosition==BattleEnum.BattlePosition.BACK then
        return {isShow = false,id=self.entity.entityId}
    end
    local shieldVal = 0
    local shieldPer = 0
    local oldhp = 0
    local oldShield = 0
    local curhp = 0
    if data ~= nil then
        oldhp = data.oldhp/self.entity.maxHp
        curhp = data.curhp/self.entity.maxHp
        if data.oldShieldMax > 0 then
            oldShield = data.oldShield/data.oldShieldMax
            shieldVal = data.curShield/data.oldShieldMax
            shieldPer = data.oldShieldMax/self.entity.maxHp
            if shieldPer > 1 then
                shieldPer = 1
            end
        end
        data.oldhp = data.curhp
        data.oldShield = data.curShield
    else
        curhp = self.entity.currentHp
        oldhp = curhp
        local shieldCur,shieldMax = self.entity:GetShieldVal()
        if shieldMax > 0 then
            shieldVal = shieldCur/shieldMax
            oldShield = shieldVal
            shieldPer = shieldMax/self.entity.maxHp
            if shieldPer > 1 then
                shieldPer = 1
            end
        end
    end


    return  {team=self.entity.playerType,val=curhp,id=self.entity.entityId,shieldPer = shieldPer,
             shieldVal = shieldVal,isShow=true,oldVal = oldhp,oldShield = oldShield}
end

local function HideChooseSkillEffect(self)
    if not IsNull(self.choose_effect_game) then
        GameObjectPool:GetInstance():RecycleGameObject(choose_effect_path,self.choose_effect_game)
        self.choose_effect_game = nil
    end
end
local function PlayChooseSkillEffect(self)
    GameObjectPool:GetInstance():GetGameObjectAsync(choose_effect_path,function(go)
        if not IsNull(go) then
            self.choose_effect_game = go
            self.choose_effect_game.transform.position = self.transform.position
        end
    end)
    TimerManager:GetInstance():SimpleTimerArgs(1,function()
        HideChooseSkillEffect(self)
    end,nil,true)
end



local function ShowOrHideEffect(self,_active)
    for i=1,#self.effectViews do
        self.effectViews[i]:ShowAndHideEffect(_active)
    end
end

--根据位置设置父节点
local function ChangeParent(self)

    local parentTranform=self.viewContext.battlePositionManager:GetTransFormById(self.entity.playerType,self.entity.position+1,self.entity.battlePosition)

    self.transform:SetParent(parentTranform)
    self.transform.localPosition=Vector3.zero
    self.transform.localEulerAngles=Vector3.zero


    if self.entity.playerType==BattleEnum.BattlePlayerType.MINE then
        if self.commonVCamGroup0==nil then
            self.commonVCamGroup0=CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.GetCommoneVCamGrop_Simple(
                    BattleConstConfig.CommonVCam0Info.name,
                    BattleConstConfig.CommonVCam0Info.followPos,
                    BattleConstConfig.CommonVCam0Info.followAngle,
                    BattleConstConfig.CommonVCam0Info.followFov,
                    BattleConstConfig.CommonVCam0Info.follow,
                    BattleConstConfig.CommonVCam0Info.lookAt
            );
            self.commonVCamGroup0.transform:SetParent(parentTranform.parent);
            self.commonVCamGroup0.transform.localPosition=Vector3.zero
            self.commonVCamGroup0.transform.localEulerAngles=Vector3.zero
        end
        if self.commonVCamGroup1==nil then
            self.commonVCamGroup1=CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.GetCommoneVCamGrop_Simple(
                    BattleConstConfig.CommonVCam1Info.name,
                    BattleConstConfig.CommonVCam1Info.followPos,
                    BattleConstConfig.CommonVCam1Info.followAngle,
                    BattleConstConfig.CommonVCam1Info.followFov,
                    BattleConstConfig.CommonVCam1Info.follow,
                    BattleConstConfig.CommonVCam1Info.lookAt
            );
            self.commonVCamGroup1.transform:SetParent(parentTranform.parent);
            self.commonVCamGroup1.transform.localPosition=Vector3.zero
            self.commonVCamGroup1.transform.localEulerAngles=Vector3.zero
        end
    end

    if self.entity.battlePosition==BattleEnum.BattlePosition.FRONT then
        self.gameObject:SetActive(true)
        ShowOrHideEffect(self,true)
    elseif   self.entity.battlePosition==BattleEnum.BattlePosition.BACK  then
        self.gameObject:SetActive(false)
        ShowOrHideEffect(self,false)
    end

    --self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYINITPASSBLOOD,GetBloodData(self))
end


local function OnSomeOneBloodShow(self,data,show_special,hide)
    if hide == 1 then
        if show_special then
            self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYSPECIALBLOOD,{isShow = false,id=self.entity.entityId})
        else
            self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYINITPASSBLOOD,{isShow = false,id=self.entity.entityId})
        end

    else
        if show_special then
            self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYSPECIALBLOOD,GetSpecialBloodData(self,data))
        else
            self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYINITPASSBLOOD,GetBloodData(self,data))
        end

    end
end



local function FillTimeLines(self,skillId,timeline)
    if self.timeLines==nil then
        self.timeLines={}
    end
    self.timeLines[skillId]=timeline
end

local function SetGuardianTimeLine(self,timeLine)
    self.guardianTimeLine=timeLine
    --self.preTimeLine = preTimeLine
    --self.guardianTimeLine_e = timeline_e
end

local function SetWinTimeLine(self,timeLine,time)
    self.winTimeLine=timeLine
    self.winTimeLine_time = time
end
local function Play(self,animName,fade)
    if not self.animator:HasState(0,CS.UnityEngine.Animator.StringToHash(animName))then
        --Logger.Log("没有动作 人物ID:"..self.entity.entityId)
        --Logger.Log("没有动作:"..animName)
        return
    end
    local ani=CS.UnityEngine.Animator.StringToHash(animName)
    if fade==true then
        self.animator:CrossFade(ani,0.5,0,0)
    else
        --Logger.Log("播放动作名:"..animName)
        self.animator:Play(ani,0,0)
    end
end

local function ChangeState(self,state)
    --Logger.Log("显示层角色改变状态"..self.entity.entityId.."state"..state)
    self.preState=self.currentState
    self.currentState=state
    self.timer=0
    if self.currentState==BattleEnum.BattleRoleState.ENTER then
        self:Play(BattleRoleView.AnimName_Name_Login)
    elseif self.currentState==BattleEnum.BattleRoleState.IDLE then
        --待机归位
        --self.transform.localPosition = Vector3.zero
        if self.entity.group.player.OneBattle.currentRoundState ==  BattleEnum.BattleRoundState.ROUNDFRONT then
            self:Play(BattleRoleView.AnimName_Name_Idle2)
        else
            self:Play(BattleRoleView.AnimName_Name_Idle)
        end
    elseif self.currentState==BattleEnum.BattleRoleState.USE_SKILL_FRONT then
        --PlayChooseSkillEffect(self)
    elseif self.currentState==BattleEnum.BattleRoleState.USE_SKILL then
        if self.entity.skillTip then
            PlayChooseSkillEffect(self)
        end

        if self.entity.lastUseSkillType == 2 then--使用召唤技能
            self.callSkillMessage = self.entity.callSkillMessage
            self:CallGuardian()
        else--使用技能
            self.currentSkillMessage=self.entity.currentSkillMessage
            ClearSaveTargetBlood(self)
            self.blood_change = {}
            if self.currentSkillMessage ~= nil and self.currentSkillMessage.cases ~= nil then
                for m, n in ipairs(self.currentSkillMessage.cases) do
                    if n ~= nil then
                        for k,v in ipairs(n.targets) do
                            if self.blood_change[v.entityId] == nil then
                                for j,z in ipairs(v.effects) do
                                    if z.release.hp ~= 0 or z.value > 0 or z.release.typeId == 1 then
                                        local view=self.viewContext.battleRoleViewManager:GetRoleViewById(v.teamId,v.entityId)
                                        local role=view.entity
                                        local shieldCur,shieldMax = role:GetShieldVal()
                                        self.blood_change[role.entityId] = {oldhp = role.hp,oldShield = shieldCur,oldShieldMax = shieldMax, curhp = role.hp,curShield = shieldCur}
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
            end
            self.blood_show = false
            self:UseSkill()
        end
        --打开遮罩
        if self.entity.lastUseSkillType == 1 then
            if not self.show_special_blood then
                self.viewContext.battleCameraManager:CameraMaskAction(1,1)
            end

        --else
        --    self.viewContext.battleCameraManager:CameraMaskAction(1,0,function()
        --        self.viewContext.battleRoleViewManager:MoveNoBattleRole(self.relRoleIds)
        --    end)

        end
        self.useSkillState = 1
    elseif self.currentState==BattleEnum.BattleRoleState.USE_SKILL_BACK then
        if self.entity.lastUseSkillType == 2 then--使用召唤技能
            --self.viewContext.battleCameraManager:PveCallEndAnim()
            --UIManager:GetInstance():Broadcast(UIMessageNames.UIEMBATTLE_CHANGE__CAM,3);
            --UIManager:GetInstance():Broadcast(UIMessageNames.UIEMBATTLE_CHANGE__CAM,1);
        end
    elseif self.currentState==BattleEnum.BattleRoleState.DEAD then
        if self.lastDeadRole then
            self:Play(BattleRoleView.AnimName_Name_Die)
        else
            self:Play(BattleRoleView.AnimName_Name_Die2)
        end

    elseif self.currentState==BattleEnum.BattleRoleState.DESTROY then
        LuaTweener.TransMoveTo(self.transform,self.transform.position,self.transform.position-Vector3.up*0.3,2,EaseFormula.InCubic)
        self.fxController:StartDissEffect(2)
    elseif self.currentState==BattleEnum.BattleRoleState.CHANGEPOSITION then
        self:Play(BattleRoleView.AnimName_Name_Login)

    end
end

local function AddNewSkillTime(self,skillId)
    local viewDataId = math.floor(BattleAssistFunction.GetCardIdByTeamAndEntityId(self.entity.playerType,self.entity.entityId))
    local skillData=DataUtil.GetData("skill")[skillId]
    local timeline_time = DataUtil.GetData("timeline_time")
    if skillData.SkillType==2 then
        local ccskillData=DataUtil.GetData("battle_ccskill_config")[skillData.ShowId]
        if ccskillData~=nil and  ccskillData.skillTimeLine~=nil then--插槽通用技能
            local time_key = viewDataId.."_"..ccskillData.skillTimeLine
            local find_val = BattleAssistFunction.FindSkillTimeLine(time_key)
            if find_val ~= nil then
                local timeLine = {}
                if find_val.Prepare ~= nil then
                    local res_timer = {res = nil,time = 0}
                    if timeline_time[find_val.Prepare] ~= nil then
                        res_timer.time = timeline_time[find_val.Prepare].duration
                    end
                    res_timer.res = ResourcesManager:GetInstance():CoLoadAsync(find_val.Prepare,typeof(CS.UnityEngine.Timeline.TimelineAsset))
                    if res_timer.res ~= nil then
                        table.insert(timeLine,res_timer)
                    else
                        Logger.LogError("资源未查找到  "..find_val.Prepare)
                    end

                end
                if find_val.Action ~= nil  then
                    local res_timer = {res = nil,time = 0}
                    if timeline_time[find_val.Action] ~= nil then
                        res_timer.time = timeline_time[find_val.Action].duration
                    end
                    res_timer.res = ResourcesManager:GetInstance():CoLoadAsync(find_val.Action,typeof(CS.UnityEngine.Timeline.TimelineAsset))
                    if res_timer.res ~= nil then
                        table.insert(timeLine,res_timer)
                    else
                        Logger.LogError("资源未查找到  "..find_val.Action)
                    end
                end
                if find_val.Return ~= nil then
                    local res_timer = {res = nil,time = 0,re_speed = 1}
                    if timeline_time[find_val.Return] ~= nil then
                        res_timer.time = timeline_time[find_val.Return].duration
                        if find_val.ReturnSpeed ~= nil then
                            res_timer.re_speed = tonumber(find_val.ReturnSpeed)
                        end
                    end
                    res_timer.res = ResourcesManager:GetInstance():CoLoadAsync(find_val.Return,typeof(CS.UnityEngine.Timeline.TimelineAsset))
                    if res_timer.res ~= nil then
                        table.insert(timeLine,res_timer)
                    else
                        Logger.LogError("资源未查找到  "..find_val.Return)
                    end
                end
                if #timeLine > 0 then
                    local key=math.floor(skillData.ShowId).."-1"
                    self:FillTimeLines(key,timeLine)
                end
            end
        end
    end
end


local function PlaySkillTimeLine(self,deadTargets,attackOffset,hitFx)
    self.playAbleDirector.playableAsset = self.timeLineGroup[self.timeLineIndex].res
    local Camgroup=nil
    local useCommonCam=false
    local followAnchor=-1
    local lookAtAnchor = -1
    local camFollowAttacker = true
    local lookAttAttacker=false
    local fieldNodes=self.viewContext.battlePositionManager:GetFieldNodesByPlayerType(self.entity.playerType)
    if self.entity.playerType==BattleEnum.BattlePlayerType.MINE then
        Camgroup=self.commonVCamGroup0
        followAnchor=BattleConstConfig.CommonVCam0Info.followAnchor
        lookAtAnchor = BattleConstConfig.CommonVCam0Info.lookAtAnchor
    elseif self.entity.playerType==BattleEnum.BattlePlayerType.ENEMY  then
        if self.mainTarget~=nil and self.mainTarget.entity.playerType~=self.entity.playerType then
            Camgroup=self.mainTarget.commonVCamGroup1
            followAnchor=BattleConstConfig.CommonVCam1Info.followAnchor
            lookAtAnchor = BattleConstConfig.CommonVCam1Info.lookAtAnchor
            camFollowAttacker = false
        end
        local skillConfig=DataUtil.GetData("skill")[self.currentSkillMessage.skillId]
        if skillConfig.DoubleHit<=0 then--表示可能连击技能，要用自身的相机动画
            useCommonCam=true
        end
    end
    local mainGame = nil
    if self.mainTarget ~= nil then
        mainGame = self.mainTarget.gameObject
        self.viewContext:SetKillCam(self.mainTarget)
    end
    --当这次攻击是由敌方发起时,需要判断这个技能是否是触发三连击的技能,如果不是触发三连击的技能,使用通用镜头.
    CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.BindingRoles(
            self.playAbleDirector,
            self.gameObject,mainGame,self.otherTargets,
            self.viewContext.battleCameraManager.camera.gameObject,
            self.skillVCam,
            Camgroup,fieldNodes,
            useCommonCam,--是否使用通用镜头
            camFollowAttacker,
            followAnchor,
            lookAttAttacker,
            lookAtAnchor,
            attackOffset,0)


    --选择技能镜头动画控制轨道
    --己方使用技能,使用SkillCamera
    --敌方使用技能,使用SkillCamera_Enemy(如果存在)
    local isEnemy = self.entity.playerType==BattleEnum.BattlePlayerType.ENEMY
    local camTrackIndex = 0
    if isEnemy then
        camTrackIndex = 1
    end
    CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.SelectTracks(self.playAbleDirector,{"SkillCamera","SkillCamera_Enemy"},camTrackIndex)

    if hitFx~=nil then
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.ReplaceTargetFx(self.playAbleDirector,hitFx.gameObject)
    else
        Logger.Log("通用被击特效没有找到")
    end

    self.useSkillPlay = true

    CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.AddTimelineEvent(self.playAbleDirector)
    if #deadTargets > 0 then
        CS.TimelineEventMsgHelper.ForbidPlayAnim(deadTargets,"rise_1",self.entity.lastUseSkillRole)
    else
        CS.TimelineEventMsgHelper.ForbidPlayAnim(nil,nil)
    end
    local wait_time = self.timeLineGroup[self.timeLineIndex].time
    if self.entity.reState == 2 and self.timeLineGroup[self.timeLineIndex].re_speed ~= nil then
        wait_time = wait_time/self.timeLineGroup[self.timeLineIndex].re_speed
        self.playAbleDirector.timeUpdateMode = CS.UnityEngine.Playables.DirectorUpdateMode.Manual
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.AddTimelineScale(self.playAbleDirector,self.timeLineGroup[self.timeLineIndex].re_speed)
    else
        self.playAbleDirector.timeUpdateMode = CS.UnityEngine.Playables.DirectorUpdateMode.GameTime
        self.playAbleDirector:Play()
    end
    --屏幕提层
    if self.currentState==BattleEnum.BattleRoleState.USE_SKILL then
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.UpdateRoleRender(self.gameObject,mainGame,self.otherTargets,1)
    else
        Logger.Log("不在技能使用状态 不提层")
    end

    self.skillTimeLineTimer = TimerManager:GetInstance():SimpleTimerArgs(wait_time,function()
        self.skillTimeLineTimer = nil
        if self.timeLineGroup[self.timeLineIndex] ~= nil then
            PlaySkillTimeLine(self,deadTargets,attackOffset,hitFx)
        else
            --timeline播放完归位
            --self.transform.localPosition = Vector3.zero
            --self.transform.parent.localPosition = Vector3.zero
            ClearSaveTargetBlood(self)
            self.timeLineGroup = {}
            self.viewContext.battleRoleViewManager:ResetBattleRole(self.relRoleIds)
        end
    end,nil,true)
    self.timeLineIndex = self.timeLineIndex+1
end


local function ResetPlayableState(self)
    if self.skillTimeLineTimer ~= nil then
        --timeline播放完归位
       -- self.transform.localPosition = Vector3.zero
        --self.transform.parent.localPosition = Vector3.zero
        TimerManager:GetInstance():SimpleTimerStop(self.skillTimeLineTimer)
        self.skillTimeLineTimer = nil
        self.viewContext.battleRoleViewManager:ResetBattleRole(self.relRoleIds)
    end

end

local function UseSkill(self)
    self.mainTarget=nil
    local attackOffset=0
    self.otherTargets={}
    self.relRoleIds = {}
    local deadTargets = {}
    for m, n in ipairs(self.currentSkillMessage.cases) do
        for k,v in ipairs(n.targets) do
            local roleView=self.viewContext.battleRoleViewManager:GetRoleViewById(v.teamId,v.entityId)
            if not self.relRoleIds[v.entityId] then
                self.relRoleIds[v.entityId] = true
                if k==1 then
                    self.mainTarget=roleView
                else
                    table.insert(self.otherTargets,roleView.gameObject)
                end
            end
            if v.hp <= 0 then
                table.insert(deadTargets,roleView.gameObject.name)
            end
        end
    end
    self.relRoleIds[self.entity.entityId] = true

    if self.mainTarget~=nil and self.mainTarget.entity.playerType~=self.entity.playerType then
        local _lookAtPoint = self.mainTarget.transform.position
        local _tarDir = (_lookAtPoint - self.transform.position).normalized
        self.transform.parent.parent.forward = _tarDir
        local distance=Vector3.Distance(_lookAtPoint,self.transform.position)
        --Logger.Log("与目标距离为.."..distance)
        attackOffset=distance-7.5*self.roleConfig.PrefabZoom
    end
    local skillData=DataUtil.GetData("skill")[self.currentSkillMessage.skillId]
    self.show_special_blood = skillData.DoubleHit > 0
    --Logger.Log("距离修正为.."..attackOffset)
    coroutine.start(function ()
        local showId=skillData.ShowId
        local time_key = math.floor(showId).."-"..math.floor(self.currentSkillMessage.doubleHit)
        local timeLine= nil
        if self.timeLines ~= nil then
            timeLine = self.timeLines[time_key]
        end
        if timeLine == nil then
            AddNewSkillTime(self,self.currentSkillMessage.skillId)
            if self.timeLines ~= nil then
                timeLine = self.timeLines[time_key]
            end
        end
        if timeLine==nil then
            Logger.LogError("查找timeline失败  使用技能timeLine Id  "..math.ceil(self.currentSkillMessage.skillId).."-"..math.ceil(self.currentSkillMessage.doubleHit)
                    .."  角色id  "..self.entity.entityId)
        else
            local hitFx = nil
            if skillData.SkillType==2 then
                local ccskillData=DataUtil.GetData("battle_ccskill_config")[showId]
                if ccskillData.HitFx~=nil then
                    hitFx=GameObjectPool:GetInstance():CoGetGameObjectAsync(ccskillData.HitFx)
                else
                    Logger.Log("没有填通用被击特效"..showId)
                end
            end
            --检测timeline是否都存在  不存在移除
            for i = #timeLine, 1,-1 do
                if timeLine[i].res == nil and timeLine[i].path ~= nil then
                    timeLine[i].res = ResourcesManager:GetInstance():CoLoadAsync(timeLine[i].path,typeof(CS.UnityEngine.Timeline.TimelineAsset))
                    if timeLine[i].res == nil then
                        Logger.LogError("资源未查找到  ".. timeLine[i].path)
                        table.remove(timeLine,i)
                    end
                end
            end
            if #timeLine == 0 then
                return
            end
            self.timeLineIndex = 1
            self.timeLineGroup = timeLine
            CS.TimelineEventMsgHelper.Instance:timelineEventReceiver('+',self.bindSkillCaseHandler)
            local position=self.transform.position
            local data={roleView=self,pos={position.x,position.y+GetBloodOffet(self),position.z},skillId=self.currentSkillMessage.skillId}
            self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.SOMEONE_START_SKILL,data)
            ResetPlayableState(self)
            PlaySkillTimeLine(self,deadTargets,attackOffset,hitFx)
            --播放镜头动画
            if not self.entity:CheckIsMainRole() and skillData.SkillType == 1 then
                local isEnemy = self.entity.playerType==BattleEnum.BattlePlayerType.ENEMY
                UIManager:GetInstance():Broadcast(UIMessageNames.UIEMBATTLE_CHANGE__CAM,1);
                if isEnemy then
                    self.viewContext.battleCameraManager:SkillCloserRole(self.transform.parent.parent.localPosition+Vector3.New(7,4,-5.56),timeLine[1].time)
                else
                    self.viewContext.battleCameraManager:SkillCloserRole(self.transform.parent.parent.localPosition+Vector3.New(7,4,-5.56),timeLine[1].time)
                end
            end
        end
    end)
end

local function CallGuardian(self)
    self.callTarget = self.viewContext.battleRoleViewManager:GetRoleViewById(self.callSkillMessage.teamId,self.callSkillMessage.entityId)
    self.relRoleIds = {[self.callSkillMessage.entityId] = true,[self.entity.entityId] = true}
    coroutine.start(function ()
        local color=self.entity.callSkill.crytalType
        self.AppearPrefabPath=""
        self.DownPrefabPath=""
        self.AppearPrefabObj=nil
        self.DownPrefabObj=nil
        if color==1 then--消耗红色水晶，用红色特效
            self.AppearPrefabPath="Art/EffectRes/Common/FX_c_other_zhaohuan_hero appear_R.prefab"
            self.DownPrefabPath="Art/EffectRes/Common/FX_c_other_zhaohuan_hero down_R.prefab"
        elseif color==3 then--消耗蓝色水晶，用蓝色特效
            self.AppearPrefabPath="Art/EffectRes/Common/FX_c_other_zhaohuan_hero appear_B.prefab"
            self.DownPrefabPath="Art/EffectRes/Common/FX_c_other_zhaohuan_hero down_B.prefab"
        else -- color==2 then--消耗黄色水晶 和 "默认" 使用黄色特效
            self.AppearPrefabPath="Art/EffectRes/Common/FX_c_other_zhaohuan_hero appear.prefab"
            self.DownPrefabPath="Art/EffectRes/Common/FX_c_other_zhaohuan_hero down.prefab"

        end
        local followAnchor=-1
        local lookAtAnchor = -1
        local camFollowAttacker = false
        local lookAttAttacker=false
        local AppearPrefab=GameObjectPool:GetInstance():CoGetGameObjectAsync(self.AppearPrefabPath)
        local isEnemy = self.entity.playerType==BattleEnum.BattlePlayerType.ENEMY

        self.AppearPrefabObj=AppearPrefab.gameObject
        if self.AppearPrefabObj~=nil then
            self.AppearPrefabObj.gameObject:SetActive(false)
        else
            Logger.LogError("No Appera Fx:" .. self.AppearPrefabPath .. " -- Color:" .. color)
        end
        local DownPrefab=GameObjectPool:GetInstance():CoGetGameObjectAsync(self.DownPrefabPath)
        self.DownPrefabObj=DownPrefab.gameObject
        if self.DownPrefabObj~=nil then
            self.DownPrefabObj.gameObject:SetActive(false)
        else
            Logger.LogError("No Down Fx:" .. self.DownPrefabPath .. " -- Color:" .. color)
        end
        ResetPlayableState(self)
        self.playAbleDirector.timeUpdateMode = CS.UnityEngine.Playables.DirectorUpdateMode.GameTime
        --播放预备tieline
        local preTimeLine = self.guardianTimeLine.pre
        if preTimeLine ~= nil then
            if preTimeLine.res == nil then
                preTimeLine.res =  ResourcesManager:GetInstance():CoLoadAsync(preTimeLine.path,typeof(CS.UnityEngine.Timeline.TimelineAsset))
            end
            if preTimeLine.res ~= nil then
                self.playAbleDirector.playableAsset = preTimeLine.res
                CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.BindingRoles(
                        self.playAbleDirector,
                        self.gameObject,nil,nil,
                        self.viewContext.battleCameraManager.camera.gameObject,
                        self.skillVCam,
                        self.commonVCamGroup0,nil,
                        false,camFollowAttacker,
                        followAnchor,
                        lookAttAttacker,
                        lookAtAnchor,
                        0,0)
                CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.UpdateRoleRender(self.gameObject,self.callTarget.gameObject,nil,1)
                self.playAbleDirector:Play()
                --播放相机镜头
                UIManager:GetInstance():Broadcast(UIMessageNames.UIEMBATTLE_CHANGE__CAM,1);
                LJAudioManger:GetInstance():PlayVoice("UI_Camera_07")
                if isEnemy then
                    self.viewContext.battleCameraManager:SkillCloserRole(self.transform.parent.parent.localPosition+Vector3.New(7,4,-5.56),preTimeLine.time)
                else
                    self.viewContext.battleCameraManager:SkillCloserRole(self.transform.parent.parent.localPosition+Vector3.New(7,4,-5.56),preTimeLine.time)
                end

                coroutine.waitforseconds(preTimeLine.time)
            end
            --self.playAbleDirector:Stop()
        end

        if self.entity.lastUseSkillType == 2 then
                self.viewContext.battleCameraManager:CameraMaskAction(1,0,function()
                    self.viewContext.battleRoleViewManager:MoveNoBattleRole(self.relRoleIds)
                end)
        end
        if isEnemy then
            if self.guardianTimeLine.other == nil then
                self.guardianTimeLine.other = ResourcesManager:GetInstance():CoLoadAsync(self.guardianTimeLine.otherPath,typeof(CS.UnityEngine.Timeline.TimelineAsset))
            end
            --如果没有敌方  查找己方
            if self.guardianTimeLine.other == nil then
                self.guardianTimeLine.other = ResourcesManager:GetInstance():CoLoadAsync(self.guardianTimeLine.mainPath,typeof(CS.UnityEngine.Timeline.TimelineAsset))
            end
            self.playAbleDirector.playableAsset = self.guardianTimeLine.other
        else
            if self.guardianTimeLine.main == nil then
                self.guardianTimeLine.main = ResourcesManager:GetInstance():CoLoadAsync(self.guardianTimeLine.mainPath,typeof(CS.UnityEngine.Timeline.TimelineAsset))
            end
            self.playAbleDirector.playableAsset = self.guardianTimeLine.main
        end

        local downFx = nil
        if not isEnemy then
            downFx = self.DownPrefabObj
        end


        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.BindingRoles_SummonAction(
                self.AppearPrefabObj,
                downFx,
                self.playAbleDirector,
                self.gameObject,self.callTarget.gameObject,nil,
                self.viewContext.battleCameraManager.camera.gameObject,
                self.skillVCam,
                self.commonVCamGroup0,nil,
                false,camFollowAttacker,
                followAnchor,
                lookAttAttacker,
                lookAtAnchor,
                0,0)

        --如果是敌方,使用敌方召唤相机
        local camAnimPath
        if isEnemy then
            camAnimPath = "Art/Roles/common/summon_camanim_Enemy.anim"
        else
            camAnimPath = "Art/Roles/common/summon_camanim.anim"
        end

        CS.TimelineEventMsgHelper.Instance:timelineEventReceiver('+',self.bindSkillCaseHandler)


        local camAnimClip = ResourcesManager:GetInstance():CoLoadAsync( camAnimPath,typeof(CS.UnityEngine.AnimationClip))
         CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.ReplaceSkillCameraAnim(
                self.playAbleDirector,
                camAnimClip
        )

        self.useSkillPlay = true

        local position=self.transform.position
        local data={roleView=self,pos={position.x,position.y+GetBloodOffet(self),position.z}}
        self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.SOMEONE_START_SKILL,data)
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.AddTimelineEvent(self.playAbleDirector)
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.UpdateRoleRender(self.gameObject,self.callTarget.gameObject,nil,1)
        self.playAbleDirector:Play()

    end)
end


local function PlayWin(self)
    self.playAbleDirector.playableAsset=self.winTimeLine
    self.playAbleDirector.extrapolationMode=CS.UnityEngine.Playables.DirectorWrapMode.Hold
    --self.viewContext.battleCameraManager.camera.transform:SetParent(self.transform)
    --new skill camera logic
    --edit by Zhangshoufeng 
    local followAnchor=-1
    local lookAtAnchor = -1
    local camFollowAttacker = false
    local lookAttAttacker=false
    CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.BindingRoles(
            self.playAbleDirector,
            self.gameObject,nil,nil,
            self.viewContext.battleCameraManager.camera.gameObject,
            self.skillVCam,
            self.commonVCamGroup0,nil,
            false,camFollowAttacker,
            followAnchor,
            lookAttAttacker,
            lookAtAnchor,
            0,0)

    --self.playAbleDirector:stopped('+',playEnd)
    self.playAbleDirector:Play()
    local function playEnd()
        if self.playWinTimeline then
            self.playWinTimeline = false
            CS.TimelineEventMsgHelper.Instance:timelineEventReceiver('-',self.bindSkillCaseHandler)
        end
        if not self.playTimeResult then
            self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYWINPLAYOVER)
            self.playTimeResult = true
        end
    end
    self.playWinTimeline = true
    self.playTimeResult = false
    self:ClearBuff()
    TimerManager:GetInstance():SimpleTimerArgs(self.winTimeLine_time,playEnd,nil,true)
    CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.AddTimelineEvent(self.playAbleDirector)
    CS.TimelineEventMsgHelper.Instance:timelineEventReceiver('+',self.bindSkillCaseHandler)
end

local function Update(self)
    for i=table.count(self.effectViews),1,-1 do
        self.effectViews[i]:Update()
    end

    if IsNull(self.animator) then
        return
    end
    if self.currentState==BattleEnum.BattleRoleState.ENTER then
        --local stateInfo=self.animator:GetCurrentAnimatorStateInfo(0)
        --if stateInfo:IsName(BattleRoleView.AnimName_Name_Idle) then
        --    self.entity:ChangeState(BattleEnum.BattleRoleState.IDLE)
        --end
    elseif self.currentState==BattleEnum.BattleRoleState.IDLE then

    elseif self.currentState==BattleEnum.BattleRoleState.USE_SKILL then
        self.timer=self.timer+Time.deltaTime
        if self.useSkillState == 1 and self.timer > self.entity.useSkillTime - 0.3 then
            UIManager:GetInstance():Broadcast(UIMessageNames.UIEMBATTLE_CHANGE__CAM,3);
            if self.entity.lastUseSkillType == 1 then
                if not self.show_special_blood then
                    self.viewContext.battleCameraManager:CameraMaskAction(0,1)
                end
            end
            self.useSkillState = 0
        end

    elseif self.currentState==BattleEnum.BattleRoleState.DEAD then

    elseif self.currentState==BattleEnum.BattleRoleState.DESTROY then
        --if not IsNull(self.transform) then
        --    self.transform:Translate(-Vector3.up * Time.deltaTime);
        --end
    elseif self.currentState==BattleEnum.BattleRoleState.CHANGEPOSITION then

    end

    --if CS.UnityEngine.Input.GetKeyDown(CS.UnityEngine.KeyCode.A) then
    --    self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYPLAYERDROPCRY,self.transform.position,self.fxController:GetAnchorTrans(2).position)
    --end
end



local function OpreateHp(self,hpChange,isCrit,hurtType)
    --发送UI血量冒字
    local type=0
    if hpChange<0 then
        type=1
    else
        type=2
    end
    local position=self.transform.position

    local data={pos={position.x,position.y+GetBloodOffet(self),position.z},num=hpChange,type=type,isCrit=isCrit,hurtType=hurtType,playerType = self.entity.playerType}

    self.viewContext.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUICHANGEHP,data)
end

local function ClearBuff(self)
    for i=table.count(self.effectViews),1,-1 do
        self.effectViews[i]:OnDestroy()
    end
end

local function OnDestroy(self)
    self.fxController:ResetDissEffect()
    self.winTimeLine=nil
    self.guardianTimeLine=nil
    self.guardianPreTimeLine = nil

    ClearBuff(self)
    if self.timeLines ~= nil then
        for k,v in pairs(self.timeLines) do
            v=nil
        end
    end
    if self.playWinTimeline then
        CS.TimelineEventMsgHelper.Instance:timelineEventReceiver('-',self.bindSkillCaseHandler)
        self.playWinTimeline = false
    end
    if self.useSkillPlay then
        CS.TimelineEventMsgHelper.Instance:timelineEventReceiver('-',self.bindSkillCaseHandler)
        self.useSkillPlay = false
    end
    if self.AppearPrefabObj~=nil then
        GameObjectPool:GetInstance():RecycleGameObject(self.AppearPrefabPath,self.AppearPrefabObj.gameObject)
        self.AppearPrefabObj = nil
        self.AppearPrefabPath = nil
    end
    if self.DownPrefabObj~=nil then
        GameObjectPool:GetInstance():RecycleGameObject(self.DownPrefabPath,self.DownPrefabObj.gameObject)
        self.DownPrefabObj = nil
        self.DownPrefabPath = nil
    end
    CS.UnityEngine.GameObject.Destroy(self.commonVCamGroup0)
    CS.UnityEngine.GameObject.Destroy(self.commonVCamGroup1)
    table.removebyvalue(self.viewContext.battleRoleViewManager.roles,self)
    GameObjectPool:GetInstance():RecycleGameObject(self.path,self.gameObject)
    HideChooseSkillEffect(self)
    if self.skillTimeLineTimer ~= nil then
        TimerManager:GetInstance():SimpleTimerStop(self.skillTimeLineTimer)
    end
end


local function AddEffectView(self,effectView)
    table.insert(self.effectViews,effectView)
end
local function GetEffectViewById(self,effectId)
    for k,v in pairs(self.effectViews) do
        if v ~=nil and v.effectId==effectId then
            return v
        end
    end
    return nil
end

local function OnSomeOneFinishSkill(self,type)
    if type == 1 then
        if self.useSkillPlay then
            CS.TimelineEventMsgHelper.Instance:timelineEventReceiver('-',self.bindSkillCaseHandler)
            self.useSkillPlay = false
        end
        local mainGame = nil
        if self.mainTarget ~= nil then
            mainGame = self.mainTarget.gameObject
        end
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.UpdateRoleRender(self.gameObject,mainGame,self.otherTargets,0)
        --self.viewContext.battleRoleViewManager:ResetBattleRole(self.relRoleIds)
        if self.show_special_blood then
            self.viewContext.battleRoleViewManager:ResetMoveBattleRole(self.relRoleIds)
            self.viewContext.battleCameraManager:CameraBackgroudMask(-1)
        end
        ClearSaveTargetBlood(self)
    elseif type == 2 then
        self.viewContext.battleRoleViewManager:ResetMoveBattleRole(self.relRoleIds)
        self.viewContext.battleCameraManager:CameraMaskAction(-1)
        CS.LJ_TimelineExtension.PlayableDirectorBindingHelper.UpdateRoleRender(self.gameObject,self.callTarget.gameObject,nil,0)
        if self.useSkillPlay then
            CS.TimelineEventMsgHelper.Instance:timelineEventReceiver('-',self.bindSkillCaseHandler)
            self.useSkillPlay = false
        end
        if self.AppearPrefabObj~=nil then
            GameObjectPool:GetInstance():RecycleGameObject(self.AppearPrefabPath,self.AppearPrefabObj.gameObject)
            self.AppearPrefabObj = nil
            self.AppearPrefabPath = nil
        end
        if self.DownPrefabObj~=nil then
            GameObjectPool:GetInstance():RecycleGameObject(self.DownPrefabPath,self.DownPrefabObj.gameObject)
            self.DownPrefabObj = nil
            self.DownPrefabPath = nil
        end
    end
end

BattleRoleView.__init=__init
BattleRoleView.OnInit=OnInit
BattleRoleView.Update=Update
BattleRoleView.OnDestroy=OnDestroy
BattleRoleView.Play=Play
BattleRoleView.ChangeState=ChangeState
BattleRoleView.FillTimeLines=FillTimeLines
BattleRoleView.SetGuardianTimeLine=SetGuardianTimeLine
BattleRoleView.UseSkill=UseSkill
BattleRoleView.CallGuardian=CallGuardian
BattleRoleView.ChangeParent=ChangeParent
BattleRoleView.OpreateHp=OpreateHp
BattleRoleView.OnSomeOneBloodShow=OnSomeOneBloodShow
BattleRoleView.SetWinTimeLine=SetWinTimeLine
BattleRoleView.PlayWin=PlayWin
BattleRoleView.GetEffectViewById=GetEffectViewById
BattleRoleView.AddEffectView=AddEffectView
BattleRoleView.GetBloodData = GetBloodData
BattleRoleView.OnSomeOneFinishSkill = OnSomeOneFinishSkill
BattleRoleView.ClearBuff = ClearBuff
return BattleRoleView