---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by guoyu.
--- DateTime: 2018/12/12 13:35
---
local BattlePlayerManager = require "GameLogic.BattleNew.Logic.Manager.BattlePlayerManager"
local OneBattle = BaseClass("OneBattle")
local BattleAssistFunction= require "GameLogic.BattleNew.BattleAssistFunction"
local BattleRole=require "GameLogic.BattleNew.Logic.Object.BattleRole"
local function __init(self)
    --阵营管理
    self.battlePlayerManager = nil
    --事件管理
    self.battleMessage = nil
    --网络层
    self.netManager = nil
    --当前状态
    self.currentState = nil
    --当前回合
    self.round = 0
    --当前回合状态
    self.currentRoundState = nil
    --当前回合使用技能队列
    self.useSkills = {}
    --回合结束时要更新的数据
    self.actionEnd = nil

    --波次是否结束
    self.isPartEnd = false
    --战斗是否结束
    self.isEnd = false
    --战斗结算信息
    self.settlement = nil
    --剧情触发器,在BattleProxy中创建
    self.storyTrigger = nil
    self.lastUseSkillRolePosId = -1
    ----是否释放技能
    --self.isUseSkill = false
    ----释放技能时长
    --self.useSkillTime = 0
    ----开始释放技能的时间
    --self.beginUseSkillTime = 0
    ----使用技能的角色
    self.lastUseSkillRole = nil
    ----使用技能類型
    --self.lastUseSkillType = 0
end

local function __CoTryTriggerStory(self, msgId, posId)
    --trigger story
    if self.storyTrigger ~= nil and self.storyTrigger:CanTrigger(msgId) then
        local msgParam = {
            msgId = msgId,
            round = self.round
        }
        if posId ~= nil then
            msgParam.posId = posId
        end
        local res = self.storyTrigger:CoTrigger(msgParam)
        if res then
            if posId ~= nil then
                Logger.Log("Battle Dialog :" .. msgId .. "|||" .. self.round .. "|||" .. posId)
            else
                Logger.Log("Battle Dialog :" .. msgId .. "|||" .. self.round)
            end

            coroutine.waituntil(function()
                return self.battlePlayerManager:isAllGroupCanBeAttacked()
            end)


            if msgId ~= 1 then
                --hide ui
                --self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYHIDEUI)
            end
            coroutine.waitforframes(1)
            --play story
            self.storyTrigger:CoPlayStory()
            coroutine.waitforframes(1)
            if msgId ~= 1 and not self.isEnd then
                --self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUIHIDETYPE, 1)
            end
        end
    end
    --end story logic
    return coroutine.yieldbreak()
end


--事件处理区
--根据服务器消息回合前恢复水晶
local function ConvertCrytals(self, Packages)


    --同步角色状态
    local _actionFront = Packages.actionFront
    if _actionFront ~= nil and not _actionFront._is_null then
        for k, v in ipairs(_actionFront.roles) do
            local battleRole = self.battlePlayerManager:GetRoleByTeamAndId(v.teamId, v.entityId)
            battleRole:SyncByServerChange(v)
        end
    end
    self.battlePlayerManager:CheckDead()
    local function isAllGroupCanBeAttack()
        return self.battlePlayerManager:isAllGroupCanBeAttacked()
    end
    coroutine.start(function()
        coroutine.waituntil(isAllGroupCanBeAttack)
        local addCrytal = { 0, 0, 0 }
        if Packages.crytal ~= nil then
            for k, v in ipairs(Packages.crytal) do
                addCrytal[v.type] = v.count
            end
        end

        if self.battlePlayerManager:isMineAttack() then
            --打开战斗UI
            local tempData = {}
            if Packages.crytalTotal ~= nil then
                for k, v in ipairs(Packages.crytalTotal) do
                    self.battlePlayerManager.player1:SetCrytalsTotal(v.type,v.count)
                    tempData[v.type] = v.count - addCrytal[v.type]
                end
            end
            if self.round <= 2 then
                self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYINITUIDATA, {cur = tempData,add = addCrytal})
            else
                UIManager:GetInstance():Broadcast(UIMessageNames.UIEMBATTLE_CHANGE__CAM,1,0.67);
                self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYROUNDDATATOUI, 1,nil,{cur = tempData,add = addCrytal})
                --self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUIHIDETYPE, 1,{cur = tempData,add = addCrytal})
            end
            self.battle_cam_change = false
        else
            local tempData = {}
            if Packages.crytalTotal ~= nil then
                for k, v in ipairs(Packages.crytalTotal) do
                    self.battlePlayerManager.player2:SetCrytalsTotal(v.type,v.count)
                    tempData[v.type] =v.count
                end
            end
            self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYROUNDDATATOUI, 2,tempData)
             --self.netManager:SendPveActionRequest(self.battlePlayerManager.attackPlayer.Id,false,nil)
        end
    end)

end


--发送选择技能
local function ChooseSkillRequest(self, data)
    --self.netManager:SendChooseSkillRequest

    self.netManager:SendChooseSkillRequest(self.battlePlayerManager.attackPlayer.Id, data[1], data[2], data[3])
end



--收到选择技能结果
local function ChooseSkillResponse(self, choose)
    local cryChangeMine = { ["reduce"] = {}, ["add"] = {} }
    local cryChangeEnemy = { ["reduce"] = {}, ["add"] = {} }
    local cryType = 0
    local success = 0
    for k, v in ipairs(choose) do
        --消耗水晶
        cryType = v.type

        if not v.cost._is_null then
            local player = self.battlePlayerManager:GetPlayerById(v.cost.teamId)
            player:OpreateCrytals(v.cost.type, -v.cost.count)
            if player.playerType == BattleEnum.BattlePlayerType.MINE then
                if cryChangeMine.reduce[v.cost.type] ~= nil then
                    cryChangeMine.reduce[v.cost.type] = cryChangeMine.reduce[v.cost.type] + v.cost.count
                else
                    cryChangeMine.reduce[v.cost.type] = v.cost.count
                end
            elseif player.playerType == BattleEnum.BattlePlayerType.ENEMY then
                if cryChangeEnemy.reduce[v.cost.type] ~= nil then
                    cryChangeEnemy.reduce[v.cost.type] = cryChangeEnemy.reduce[v.cost.type] + v.cost.count
                else
                    cryChangeEnemy.reduce[v.cost.type] = v.cost.count
                end
            end
        end
        --获得水晶
        if not v.crytalInSkill._is_null and table.ProtoRepeatedCount(v.crytalInSkill) > 0 then
            for j, z in ipairs(v.crytalInSkill) do
                local player = self.battlePlayerManager:GetPlayerById(z.teamId)
                player:OpreateCrytals(z.type, z.count)
                if player.playerType == BattleEnum.BattlePlayerType.MINE then
                    if cryChangeMine.add[z.type] ~= nil then
                        cryChangeMine.add[z.type] = cryChangeMine.add[z.type] + z.count
                    else
                        cryChangeMine.add[z.type] = z.count
                    end
                elseif player.playerType == BattleEnum.BattlePlayerType.ENEMY then
                    if cryChangeEnemy.add[z.type] ~= nil then
                        cryChangeEnemy.add[z.type] = cryChangeEnemy.add[z.type] + z.count
                    else
                        cryChangeEnemy.add[z.type] = z.count
                    end
                end
                if math.abs(z.count) > 0 then
                    success = 1
                end
            end
        end
    end

    --通知UI水晶改变
    local cryChangeData = { cryChangeMine, cryChangeEnemy, cryType, success }
    self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUICRYCHANGE, cryChangeData)

end

--发送使用技能
local function SendPveActionRequest(self, data)
    if self.currentRoundState == BattleEnum.BattleRoundState.ROUNDFRONT then
        self.netManager:SendPveActionRequest(self.battlePlayerManager.attackPlayer.Id, false,data)
    end
end

local function PveAction(self, Packages)
    local roundAction = Packages.roundAction

    if not Packages.actionEnd._is_null then
        self.actionEnd = Packages.actionEnd
    end
    local skill_choose = Packages.choose
    if skill_choose ~= nil and not skill_choose._is_null then
        ChooseSkillResponse(self,skill_choose)
    end

    self.isPartEnd = Packages.isPartEnd
    self.isEnd = Packages.isEnd
    if not Packages.settlement._is_null then
        self.settlement = Packages.settlement
        if self.settlement.isSuccess == true then
            self.battleMessage:Broadcast(BattleEnum.BattleMessage.SET_MINE_LAST_USE_SKILL, self.settlement.killEntityId)
        end
    end

    if not roundAction._is_null then
        for k, v in ipairs(roundAction.actionResult) do
            --local battleRole=self.battlePlayerManager:GetRoleByTeamAndId(v.teamId,v.entityId)
            local battleRole = self.battlePlayerManager:GetRoleByTeamAndId(v.teamId,v.entityId)
            if v.actionType == 0 then
                local role= BattleRole.New()
                role:OnInit(v.callGuardian.guardian,battleRole.group)
                local useSkillData = { role = { v.teamId, v.entityId }, isCall = true,guardianRole = role}
                table.insert(self.useSkills, useSkillData)
            elseif v.actionType == 1 then

                local isGuaidSkill = false
                if battleRole ~= nil and not battleRole:CheckIsMainRole() then
                    local skill_static = DataUtil.GetData("skill")
                    if skill_static[v.actionSkill.skillId] ~= nil and skill_static[v.actionSkill.skillId].SkillType == 1 then
                        isGuaidSkill = true
                    end
                end
                local playerType = self.battlePlayerManager:GetPlayerById(v.teamId).playerType
                local _data = BattleAssistFunction.GetSkillTimeLineTime(playerType, v.entityId,v.actionSkill.skillId,v.actionSkill.doubleHit)
                local useSkillData = { role = { v.teamId, v.entityId }, isCall = false, actionSkill = v.actionSkill,timeData = _data,returnState = 0,isGuaidSkill = isGuaidSkill}
                table.insert(self.useSkills, useSkillData)
            end
        end
        --在此判断出执行方案
        for i = 1,#self.useSkills do
            if i < #self.useSkills then
                if self.useSkills[i].timeData ~= nil then
                    --如果攻击单位不同
                    if self.useSkills[i].timeData.type == 1 and self.useSkills[i+1].timeData ~= nil then
                        if self.useSkills[i+1].role[2] ~= self.useSkills[i].role[2] then
                            self.useSkills[i].returnState = 1
                        else
                            self.useSkills[i].timeData.other_time = self.useSkills[i].timeData.other_time+self.useSkills[i].timeData.re_time/self.useSkills[i].timeData.re_speed
                            self.useSkills[i].returnState = 2
                        end
                    else
                        self.useSkills[i].timeData.other_time = self.useSkills[i].timeData.other_time+self.useSkills[i].timeData.re_time
                    end
                end
            else
                if self.useSkills[i].timeData ~= nil then
                    self.useSkills[i].timeData.other_time = self.useSkills[i].timeData.other_time+self.useSkills[i].timeData.re_time
                end
            end

        end

    end
    --if self.isEnd then
    --    self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYHIDEUI,1)
    --end
    self:ChangeRoundState(BattleEnum.BattleRoundState.ROUNDBATTLE)
end

local function OnSomeOneOnClick(self, teamId, entityId)
    local role = self.battlePlayerManager:GetRoleByTeamAndId(teamId, entityId)
    local data = {}
    data.id = role.entityId
    data.level = role.level
    data.currentHp = role.currentHp
    data.skill = {}
    for k, v in pairs(role.skills) do
        data.skill[k] = { v.skillId, v.crytalType, v.crytalCount, v.level }
    end
    self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUIROLEDATA, data)
end

local function OnSomeOneHpZero(self,entity,timeScaleVal,timeVal)
    Time.timeScale=timeScaleVal
    TimerManager:GetInstance():SimpleTimerArgs(timeVal,function ()
        Time.timeScale=1
    end,nil,true,false,true)
end

local function AddEventListener(self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.CONVERTCRYTALS, ConvertCrytals, self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.NOTIFYSELECTSKILL, ChooseSkillRequest, self)
    --self.battleMessage:AddListener(BattleEnum.BattleMessage.SERVER_CHOOSESKILL_RESPONSE, ChooseSkillResponse, self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.NOTIFYBATTLESTART, SendPveActionRequest, self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.PVEROUNDDATA, PveAction, self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.SOMEONE_FINISH_SKILL, self.UseSkillLogic, self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.NOTIFYClOSEROVER, self.UseSkillLogic, self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.NOTIFYGETROLEDATA, OnSomeOneOnClick, self)
    self.battleMessage:AddListener(BattleEnum.BattleMessage.SOMEONE_HP_ZERO, OnSomeOneHpZero, self)
end

local function RemoveEventListener(self)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.CONVERTCRYTALS, ConvertCrytals)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.NOTIFYSELECTSKILL, ChooseSkillRequest)
    --self.battleMessage:RemoveListener(BattleEnum.BattleMessage.SERVER_CHOOSESKILL_RESPONSE, ChooseSkillResponse)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.NOTIFYBATTLESTART, SendPveActionRequest)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.PVEROUNDDATA, PveAction)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.SOMEONE_FINISH_SKILL, self.UseSkillLogic)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.NOTIFYClOSEROVER, self.UseSkillLogic)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.NOTIFYGETROLEDATA, OnSomeOneOnClick)
    self.battleMessage:RemoveListener(BattleEnum.BattleMessage.SOMEONE_HP_ZERO, OnSomeOneHpZero)
end

local function OnInit(self, battleMessage, myTeam,myGuard, battlePackages, netManager, storyTrigger)
    self.battleMessage = battleMessage
    self.netManager = netManager
    self.battlePlayerManager = BattlePlayerManager.New(self)
    self.battlePlayerManager:OnInit(self, myTeam,myGuard, battlePackages)
    self.round = 1
    self.storyTrigger = storyTrigger
    self:ChangeState(BattleEnum.BattleState.WAVEAWAKE)
    AddEventListener(self)
end

local function Update(self)
    if self.currentState == BattleEnum.BattleState.WAVEAWAKE then

    elseif self.currentState == BattleEnum.BattleState.BATTLE then
        if self.currentRoundState == BattleEnum.BattleRoundState.ROUNDFRONT then

        elseif self.currentRoundState == BattleEnum.BattleRoundState.ROUNDBATTLE then

        elseif self.currentRoundState == BattleEnum.BattleRoundState.ROUNDEND then

        end
    elseif self.currentState == BattleEnum.BattleState.WAVEEND then

    elseif self.currentState == BattleEnum.BattleState.ENDBATTLE then

    end
    self.battlePlayerManager:Update()
end

local function ChangeState(self, state)
    self.currentState = state
    if self.currentState == BattleEnum.BattleState.WAVEAWAKE then
        coroutine.start(function()
            self.battlePlayerManager:CreateWaveRoles()
            coroutine.waitforframes(1)
            __CoTryTriggerStory(self, 1, -1)
            self:ChangeState(BattleEnum.BattleState.BATTLE)
        end)

    elseif self.currentState == BattleEnum.BattleState.BATTLE then
        self:ChangeRoundState(BattleEnum.BattleRoundState.ROUNDFRONT)
    elseif self.currentState == BattleEnum.BattleState.WAVEEND then

    elseif self.currentState == BattleEnum.BattleState.ENDBATTLE then
        local function isBattleCanBeEnd()
            return not self.battlePlayerManager:isSomeOneDying()
        end
        coroutine.start(function()
            coroutine.waituntil(isBattleCanBeEnd)
            __CoTryTriggerStory(self, 2, nil)
            self.battleMessage:Broadcast(BattleEnum.BattleMessage.BATTLE_FINISH, self.settlement)
        end
        )
    end
end

local function ChangeRoundState(self, state)
    self.currentRoundState = state
    if self.currentRoundState == BattleEnum.BattleRoundState.ROUNDFRONT then

        coroutine.start(function()
            __CoTryTriggerStory(self, 3, nil)
            self.netManager:SendConvertCrytalsRequest(self.battlePlayerManager.attackPlayer.Id)
        end)

    elseif self.currentRoundState == BattleEnum.BattleRoundState.ROUNDBATTLE then

        --半隐藏UI
        if not self.battlePlayerManager:isMineAttack() then
            self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYPAUSE,2)
        else
            self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYPAUSE,1)
        end
        self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYUIHIDETYPE, 2)

        self.lastUseSkillRole = nil
        --己方镜头拉近
        if #self.useSkills > 0 and not self.battle_cam_change then
            if self.useSkills[1].isCall or self.useSkills[1].isGuaidSkill then
                self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYClOSERBEGIN,Bind(self,self.UseSkillLogic))
            else
                self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYClOSERBEGIN)
                self:UseSkillLogic()
            end
            self.battle_cam_change = true
        else
            self:UseSkillLogic()
        end

    elseif self.currentRoundState == BattleEnum.BattleRoundState.ROUNDEND then
        Time.timeScale=1
        local function isAllGroupCanBeAttack()
            return self.battlePlayerManager:isAllGroupCanBeAttacked()
        end
        coroutine.start(function()
            __CoTryTriggerStory(self, 4, nil)
            --回合后同步角色状态
            if self.actionEnd ~= nil then
                if not self.actionEnd.roles._is_null and table.ProtoRepeatedCount(self.actionEnd.roles) > 0 then
                    for k, v in ipairs(self.actionEnd.roles) do
                        local battleRole = self.battlePlayerManager:GetRoleByTeamAndId(v.teamId, v.entityId)
                        battleRole:SyncByServerChange(v)
                    end
                end
                self.actionEnd = nil
            end
            self.battlePlayerManager:CheckDead()
            if self.isEnd == true then
                self:ChangeState(BattleEnum.BattleState.ENDBATTLE)
                return
            end
            coroutine.waituntil(isAllGroupCanBeAttack)
            self.battlePlayerManager:ChangeAttacker()
            if not self.battlePlayerManager:isMineAttack() then
                    --coroutine.waitforframes(1)
                    --coroutine.waitforseconds(1.5)
                    --self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYPAUSE, false)
                    --coroutine.waitforframes(1)
                    self.round = self.round + 1
                    self:ChangeRoundState(BattleEnum.BattleRoundState.ROUNDFRONT)
            else
                --self.battleMessage:Broadcast(BattleEnum.BattleMessage.NOTIFYPAUSE, false)
                self.round = self.round + 1
                self:ChangeRoundState(BattleEnum.BattleRoundState.ROUNDFRONT)
            end
        end)

    end
end

local function UseSkillLogic(self)
    self.battlePlayerManager:CheckDead()
    local function isAllGroupCanBeAttack()
        return self.battlePlayerManager:isAllGroupCanBeAttacked()
    end
    coroutine.start(function()
        coroutine.waituntil(isAllGroupCanBeAttack)

        if self.lastUseSkillRolePosId > 0 then
            __CoTryTriggerStory(self, 6, self.lastUseSkillRolePosId)
            self.lastUseSkillRolePosId = -1
        end

        if table.count(self.useSkills) == 0 then
            self:ChangeRoundState(BattleEnum.BattleRoundState.ROUNDEND)
            return
        end

        local useSkillData = self.useSkills[1]
        local battleRole = self.battlePlayerManager:GetRoleByTeamAndId(useSkillData.role[1], useSkillData.role[2])

        local rolePosId = -1
        if battleRole.playerType == BattleEnum.BattlePlayerType.MINE then
            rolePosId = 1 + battleRole.position
        else
            rolePosId = 11 + battleRole.position
        end

        __CoTryTriggerStory(self, 5, rolePosId)
        if useSkillData.isCall == true then
            battleRole:CallGuardianSkill(self.lastUseSkillRole ~= battleRole,useSkillData.guardianRole)
        else
            if useSkillData.returnState > 0 then
                battleRole:UseSkill(useSkillData.actionSkill,self.lastUseSkillRole~= battleRole,useSkillData.timeData.other_time,useSkillData.timeData.re_time,useSkillData.returnState,self.isEnd and #self.useSkills == 1)
            else
                battleRole:UseSkill(useSkillData.actionSkill,self.lastUseSkillRole~= battleRole,useSkillData.timeData.other_time,0,0,self.isEnd and #self.useSkills == 1)
            end

        end

        self.lastUseSkillRolePosId = rolePosId
        self.lastUseSkillRole = battleRole
        table.remove(self.useSkills, 1)
    end)
end
local function OnDestroy(self)
    self.battlePlayerManager:OnDestroy()
    RemoveEventListener(self)
end

OneBattle.__init = __init
OneBattle.OnInit = OnInit
OneBattle.Update = Update
OneBattle.OnDestroy = OnDestroy
OneBattle.ChangeState = ChangeState
OneBattle.ChangeRoundState = ChangeRoundState
OneBattle.UseSkillLogic = UseSkillLogic
return OneBattle