---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2019/9/10 16:17
---
local BiographyData = BaseClass("BiographyData",Singleton)

local StaticCardDailyLevelData = DataUtil.GetData("card_daily_level")
local BattleFieldManager=require "GameLogic.BattleNew.Logic.Manager.BattleFieldManager"

-- 排序卡牌
local function OnSortCard(self)
    table.sort(self._cardIdGroup, function(a,b)
        local r
        -- 上阵
        local aIsInBattle = CardData:GetInstance():CheckIsInBattle(a) and 1 or 0
        local bIsInBattle = CardData:GetInstance():CheckIsInBattle(b) and 1 or 0
        if aIsInBattle == bIsInBattle then
            -- 品质
            local aQuality = CardData:GetInstance().cards[a].quality
            local bQuality = CardData:GetInstance().cards[b].quality
            if aQuality == bQuality then
                -- 战力
                local aPower = CardData:GetInstance().cards[a].power
                local bPower = CardData:GetInstance().cards[b].power
                if aPower == bPower then
                    -- ID
                    r = a > b
                else
                    r = aPower > bPower
                end
            else
                r = aQuality > bQuality
            end
        else
            r = aIsInBattle > bIsInBattle
        end
        return r
    end)
    local sortData = {}
    for k, v in pairs(self._cardIdGroup) do
        sortData[v] = self._data[v]
    end
    self._data = sortData
end

-- 刷新红点状态
local function OnRefreshRed(self)
    self.showRed = self.ticket > 0
    OnSortCard(self)
end

-- 是否有该卡牌
local function IsHasCard(self, cardId)
    local cardList = CardData:GetInstance().cards
    for k, v in pairs(cardList) do
        if v ~= nil then
            if v.id == cardId then
                return true
            end
        end
    end
    return false
end

-- 跨天
local function DayFlushIndication(self)
    for k, v in pairs(self._data) do
        for m, n in pairs(v) do
            n.HaveTimes = n.AwardTimes
            n.ResetTimes = 0
        end
    end
    if self.ticket + DataUtil.GetData("global")[177].valueN > DataUtil.GetData("global")[178].valueN then
        self.ticket = math.max(self.ticket, DataUtil.GetData("global")[178].valueN)
    else
        self.ticket = self.ticket + DataUtil.GetData("global")[177].valueN
    end
    self.haveBuyNum = 0
    DataManager:GetInstance():Broadcast(DataMessageNames.ON_BIOGRAPHY_REFRESH)
end

-- 刷新数据
local function RefreshData(self)
    for k, v in pairs(StaticCardDailyLevelData) do
        if self:IsHasCard(v.CardId) and self._data[v.CardId] == nil then
            table.insert(self._cardIdGroup, v.CardId)
            for m, n in pairs(v.Levels) do
                n.HaveTimes = n.AwardTimes
                n.ResetTimes = 0
                n.PassLevel = 0 -- = v.Levels[table.count(v.Levels) - 1].Id
            end
            self._data[v.CardId] = v.Levels
        end
    end
end

local function __init(self)
    self.ticket = 0
    self.haveBuyNum = 0
    self.fightId = 0
    self.selectCardId = 0
    self.isShowCostTip = true
    self._limitCardGroup = {}
    self._cardIdGroup = {}
    self._data = {}
    self._cardIdGroup = {}
    RefreshData(self)
end

-- 通关关卡，刷新数据
local function OnPassLevel(self)
    for k, v in pairs(self._data) do
        for m, n in pairs(v) do
            if n.Id == self.fightId then
                n.HaveTimes = n.HaveTimes - 1
                if n.PassLevel <= m then
                    for i, j in pairs(v) do
                        j.PassLevel = m + 1
                    end
                end
                self.fightId = 0
                break
            end
        end
    end
    self.ticket = self.ticket - 1
    OnRefreshRed(self)
end

local function GetAllBiographyData(self)
    local state,type,des= UnlockData:GetInstance():GetLockDataState(319)
    if not state then
        return
    end
    if self.have_send then
        Logger.LogError("已经请求过传记")
        return
    else
        self.have_send = true
    end
    local mission_info_id = MsgIDDefine.PBCHAPTER_GET_CARD_BIOGRAPHY_LIST_REQUEST
    NetManager:GetInstance():SendMessage(mission_info_id,nil,function (msg_obj)
         if msg_obj.OpCode ~= 0 then
            Logger.Log("ERROR PBCHAPTER_GET_CARD_BIOGRAPHY_LIST_REQUEST~~")
            UISpecial:GetInstance():UITipText(msg_obj.Packages.msg)
        else
            self.ticket = msg_obj.Packages.ticket
            self.haveBuyNum = msg_obj.Packages.haveBuyNum
            -- 章节通过最大关卡
            for k, v in ipairs(msg_obj.Packages.haveClearMap) do
                local chaId = v.chaId
                for m, n in pairs(StaticCardDailyLevelData) do
                    if m == chaId then
                        for i = 1, #self._data[n.CardId] do
                            self._data[n.CardId][i].PassLevel = v.id
                        end
                        break
                    end
                end
            end
            -- 关卡数据
            for k, v in ipairs(msg_obj.Packages.biography) do
                local chaId = v.chapterId
                for m, n in pairs(self._data) do
                    for i, j in pairs(n) do
                        if j.Id == chaId then
                            self._data[m][i].HaveTimes = v.count
                            self._data[m][i].ResetTimes = v.resetCount
                        end
                    end
                end
            end
            OnRefreshRed(self)
            DataManager:GetInstance():Broadcast(DataMessageNames.ON_BIOGRAPHY_REFRESH)
        end
    end)
end

local function OnBiographyLevelEnter(self, cardIndex, levelIndex)
    if self.ticket <= 0 then
        UISpecial:GetInstance():UITipText("今日挑战总次数不足")
        return
    end
    self.selectCardId = self._cardIdGroup[cardIndex]
    self._limitCardGroup = self._data[self._cardIdGroup[cardIndex]][levelIndex].CardLimit
    local info_id = MsgIDDefine.PBFIGHT_ENTER_CARD_BIOGRAPHY_REQUEST
    local info = (MsgIDMap[info_id])()
    local enterLevelId = self._data[self._cardIdGroup[cardIndex]][levelIndex].Id
    info.chapterId = enterLevelId
    self.fightId = enterLevelId
    for k, v in pairs(self._data) do
        for m, n in pairs(v) do
            if n.Id == self.fightId then
                self.fightSceneName = n.SceneName
                break
            end
        end
    end
    BattleFieldManager:GetInstance().fightId = enterLevelId
    BattleFieldManager:GetInstance().battleType = BattleEnum.BattleType.BIOGRAPLY
    BattleFieldManager:GetInstance().sceneConfigId=DataUtil.GetData("arena_message")[1].ArenaPos
    NetManager:GetInstance():SendMessage(info_id,info,function (msg_obj)
        if msg_obj.OpCode ~= 0 then
            Logger.Log("ERROR PBFIGHT_ENTER_CARD_BIOGRAPHY_REQUEST~~")
            UISpecial:GetInstance():UITipText(msg_obj.Packages.msg)
            return
        else
            BattleFieldManager:GetInstance().battlePackages=msg_obj.Packages.enterFight
            UIManager:GetInstance():OpenWindow(UIWindowNames.UIEmBattle2D)
        end
    end)
end

local function OnBiographyLevelPass(self, id)
    if self.ticket <= 0 then
        UISpecial:GetInstance():UITipText("今日挑战总次数不足")
        return
    end
    local info_id = MsgIDDefine.PBCHAPTER_SWEEP_BIOGRAPHY_REQUEST
    local info = (MsgIDMap[info_id])()
    info.id = id
    self.fightId = id
    NetManager:GetInstance():SendMessage(info_id,info,function (msg_obj)
        if msg_obj.OpCode ~= 0 then
            Logger.Log("ERROR PBCHAPTER_PASS_DAILY_LEVEL_REQUEST~~")
            UISpecial:GetInstance():UITipText(msg_obj.Packages.msg)
            return
        else
            DataUtil.ParseDropItem(msg_obj.Packages.dropItem)
            UIManager:GetInstance():OpenWindow(UIWindowNames.UICommGetRewards, msg_obj.Packages.dropItem,nil,1)
            OnPassLevel(self)
            DataManager:GetInstance():Broadcast(DataMessageNames.ON_BIOGRAPHY_REFRESH)
        end
    end)
end

local function OnResetBiographyTimes(self, id, costNum)
    local info_id = MsgIDDefine.PBCHAPTER_RESET_BIOGRAPHY_TIMES_REQUEST
    local info = (MsgIDMap[info_id])()
    info.id = id
    NetManager:GetInstance():SendMessage(info_id,info,function (msg_obj)
        if msg_obj.OpCode ~= 0 then
            Logger.Log("ERROR PBCHAPTER_RESET_BIOGRAPHY_TIMES_REQUEST~~")
            UISpecial:GetInstance():UITipText(msg_obj.Packages.msg)
            return
        else
            for k, v in pairs(self._data) do
                for m, n in pairs(v) do
                    if n.Id == id then
                        n.HaveTimes = self._data[k][m].AwardTimes
                        n.ResetTimes = n.ResetTimes + 1
                    end
                end
            end
            BackpackData:GetInstance():UpdateItemData(CoinDefine.Diamond,-costNum)
            DataManager:GetInstance():Broadcast(DataMessageNames.ON_BIOGRAPHY_REFRESH)
        end
    end)
end

local function OnBuyBiographyTimes(self, num, costNum)
    local info_id = MsgIDDefine.PBCHAPTER_BUY_BIOGRAPHY_TIMES_REQUEST
    local info = (MsgIDMap[info_id])()
    info.num = num
    NetManager:GetInstance():SendMessage(info_id,info,function (msg_obj)
        if msg_obj.OpCode ~= 0 then
            Logger.Log("ERROR PBCHAPTER_RESET_BIOGRAPHY_TIMES_REQUEST~~")
            UISpecial:GetInstance():UITipText(msg_obj.Packages.msg)
            return
        else
            self.ticket = msg_obj.Packages.nowTimes
            self.haveBuyNum = msg_obj.Packages.haveBuyNum
            BackpackData:GetInstance():UpdateItemData(CoinDefine.Diamond,-costNum)
            DataManager:GetInstance():Broadcast(DataMessageNames.ON_BIOGRAPHY_REFRESH)
        end
    end)
end

BiographyData.__init = __init
BiographyData.OnPassLevel = OnPassLevel
BiographyData.GetAllBiographyData = GetAllBiographyData
BiographyData.OnBiographyLevelEnter = OnBiographyLevelEnter
BiographyData.OnBiographyLevelPass = OnBiographyLevelPass
BiographyData.OnResetBiographyTimes = OnResetBiographyTimes
BiographyData.OnBuyBiographyTimes = OnBuyBiographyTimes
BiographyData.RefreshData = RefreshData
BiographyData.IsHasCard = IsHasCard
BiographyData.DayFlushIndication = DayFlushIndication
return BiographyData