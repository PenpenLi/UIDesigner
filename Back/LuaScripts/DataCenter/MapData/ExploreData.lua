---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by LJ095.
--- DateTime: 2019/6/25 17:37
---

local ExploreTeamData={
    team={},--上阵的卡牌列表
    begin_time=0,--初始时间
    level_id=0,--挂机点id
    haveHangTime=0,--当前最大关卡已挂机时间（开启下一个使用）
    maxLevelId=0,--当前已挂机的最大关卡id
    speedUpTimes=0,--今日已经快速挂机次数
    buySpeedUpTiems=0,--今日购买快速挂机次数
    historyForce=0,--历史最高战斗力
    haveHangMaxId=0,--已经挂机过的最大关卡id
}

local ExploreData = BaseClass("ExploreData", Singleton)
local ExploreTeamData = DataClass("ExploreTeamData", ExploreTeamData)
local chapterData = DataUtil.GetData("hang_up_chapter")
local hang_up_data = DataUtil.GetData("hang_up_level")


local function CheckOpen(_levelId)
    if MapData:GetInstance():CheckPassLevel(_levelId) then
        return true;
    end
    return false;
end

--创建章节列表
local function CreatChapterList(self,_chapterList)

    local all_level={};
    self.allLevelDic={};
    for i, v in pairs(hang_up_data) do
        local tempPass={};
        tempPass.xlsxData=v;
        tempPass.id=i;
        tempPass.isOpen=CheckOpen(chapterData[v.ChaId].NeedPlotLevel);;
        table.insert(all_level,tempPass)
    end
    table.sort(all_level,function(a,b) return a.id<b.id end)
    self.allLevel=all_level;

    local temp = {}
    for i, v in ipairs(all_level) do
        local index = temp[v.xlsxData.ChaId]
        if index == nil then
            local tempChapter={};
            local chapterXlsxData=chapterData[v.xlsxData.ChaId];
            tempChapter.isOpen=CheckOpen(chapterXlsxData.NeedPlotLevel);
            tempChapter.needPlotLevel=chapterXlsxData.NeedPlotLevel
            tempChapter.id=v.xlsxData.ChaId;
            tempChapter.name=chapterXlsxData.Name;
            tempChapter.passList={};
            table.insert(_chapterList,tempChapter);
            index = #_chapterList
            temp[v.xlsxData.ChaId] = index
        end
        self.allLevelDic[v.id]=i;
        table.insert(_chapterList[index].passList,v)

    end
end


local function __init(self)
    -- 所有服务器列表
    self.dataState=0;--数据状态 0--未获取过数据，1获取了数据
    self.teamList={};
    self.chapterList={};
    CreatChapterList(self,self.chapterList);
end


--获取关卡对应的章节索引
local function GetChapterIndexByLevelId(self,_levelId)
    local levelData=hang_up_data[_levelId];
    if levelData~=nil then
        local chaId=levelData.ChaId;
        for i, v in ipairs(self.chapterList) do
            if v.id==chaId then
                return i;
            end
        end
    end
end



--刷新单个队伍的信息
local function RefreshSingleTeam(self,_cardList)
    if _cardList~=nil and #_cardList>0 then
        self.teamData.team={};
        for a, b in ipairs(_cardList) do
            table.insert(self.teamData.team,b);
        end
    end
end

--更新队伍数据
local function RefreshTeamData(self,data)
    if data~= nil and not data._is_null then
        for i, v in ipairs(self.teamList) do
            if data.teamId==v.id then
               v.begin_time=data.startTime;
                v.drop_show_list=DataUtil.GetServerRewardList(data.reward);
                return;
            end
        end
    end
end

local function ParseServerData(self,data)
    self.teamData={};
    if data~= nil and not data._is_null then
        local tempTeam=ExploreTeamData.New();
        tempTeam.team={};
        if data.teamIds~=nil then
            for a, b in ipairs(data.teamIds) do
                table.insert(tempTeam.team,b);
            end
        end
        tempTeam.begin_time=data.startTime;
        tempTeam.level_id=data.levelId;
        tempTeam.haveHangTime=data.haveHangTime;
        tempTeam.maxLevelId=data.maxLevelId;
        tempTeam.speedUpTimes=data.speedUpTime;
        tempTeam.buySpeedUpTiems=data.buySpeedUpTime;
        tempTeam.historyForce=data.historyMaxFighting;
        tempTeam.haveHangMaxId=data.haveHangMaxId;
        self.teamData=tempTeam;
    end
    DataManager:GetInstance():Broadcast(DataMessageNames.ON_EXPLORE_DATA_INIT,self.teamList);
end

--获取是否已经挂机
local function GetHaveExploreDataState(self)
    if self.teamData then
        local state=self.teamData.level_id>0 and 1 or 0;
        return state;
    end
    return 0;
end

--获取探险的数据状态
local function GetExploreDataState(self,_callBack)
    --if self.dataState==0 then
    self:SendGetOnHookListRequest(_callBack);
--[[    else
        if self.teamData then
            _callBack(GetHaveExploreDataState(self));
        end
    end]]
end

--获取探险挂机队伍列表
local function SendGetOnHookListRequest(self,_callBack)
    local msdId = MsgIDDefine.PBCHAPTER_GET_ONHOOK_LIST_REQUEST
    local msdObj = MsgIDMap[msdId]()
    NetManager:GetInstance():SendMessage(msdId,msdObj,function(msg_obj)
        if msg_obj.OpCode ~= 0 then
            Logger.Log("OnRecvPveStart出错了~")
            UISpecial:GetInstance():UITipText(msg_obj.Packages.msg)
            return
        else
            self.dataState=1;
            ParseServerData(self,msg_obj.Packages.onHookTeamInfo);
            _callBack(GetHaveExploreDataState(self))
        end
    end)
end

--刷新当前最大关卡id和关机时长
local function RefreshMaxLvAndHangTime(self,_maxLv,_hangTime,startTime)
    self.maxLevelId=_maxLv;
    self.haveHangTime=_hangTime;
end

--刷新单个队伍当挂机关卡
local function RefreshSingleTeamLvId(self,_onHookTeamInfo)
    self.teamData.level_id=_onHookTeamInfo.levelId;
    self.teamData.historyForce=_onHookTeamInfo.historyMaxFighting;
    self.teamData.begin_time=_onHookTeamInfo.startTime;
    self.teamData.maxLevelId=_onHookTeamInfo.maxLevelId;
    self.teamData.haveHangMaxId=_onHookTeamInfo.haveHangMaxId;
    self.teamData.haveHangTime=_onHookTeamInfo.haveHangTime;
    self.teamData.buySpeedUpTiems=_onHookTeamInfo.buySpeedUpTime;
    self.teamData.speedUpTimes=_onHookTeamInfo.speedUpTime;
    if _onHookTeamInfo.teamIds~=nil then
        self.teamData.team={};
        for a, b in ipairs(_onHookTeamInfo.teamIds) do
            table.insert(self.teamData.team,b);
        end
    end
end

--获取上一关的关卡id
local function GetLastLevelId(self,_levelId)
    local curLvIndex=self.allLevelDic[_levelId];
    local lastLvIndex=curLvIndex-1 <=1 and 1 or curLvIndex-1;
    local lastLvId=self.allLevel[lastLvIndex].id;
    return lastLvId;
end
--获取下一关关卡id
local function GetNexLevelId(self,_levelId)
    local curLvIndex=self.allLevelDic[_levelId];
    local nexLvIndex=curLvIndex+1>#self.allLevel and curLvIndex or curLvIndex+1;
    local nexLvId=self.allLevel[nexLvIndex].id;
    return nexLvId,self.allLevel[nexLvIndex];
end

--刷新加速次数
local function RefreshAddSpeedTimes(self,_hangUpData)
    if not _hangUpData._is_null then
        self.teamData.speedUpTimes=_hangUpData.speedUpTime;
    end
end

--刷新开始挂机时间和挂机时长
local function RefreshHangUpStarTime(self,_starTime)
    if not _starTime._is_null then
        self.teamData.begin_time=_starTime;
    end
end

--刷新探险时间
local function RefreshHangUpTime(self,_hangTime)
    self.teamData.haveHangTime=_hangTime;
end

ExploreData.RefreshHangUpTime=RefreshHangUpTime;
ExploreData.RefreshHangUpStarTime=RefreshHangUpStarTime;
ExploreData.RefreshAddSpeedTimes=RefreshAddSpeedTimes;
ExploreData.GetExploreDataState=GetExploreDataState;
ExploreData.GetLastLevelId=GetLastLevelId;
ExploreData.ParseServerData = ParseServerData
ExploreData.__init = __init
ExploreData.SendGetOnHookListRequest=SendGetOnHookListRequest;
ExploreData.RefreshSingleTeam=RefreshSingleTeam;
ExploreData.GetChapterIndexByLevelId=GetChapterIndexByLevelId;
ExploreData.RefreshTeamData=RefreshTeamData;
ExploreData.RefreshMaxLvAndHangTime=RefreshMaxLvAndHangTime;
ExploreData.RefreshSingleTeamLvId=RefreshSingleTeamLvId;
ExploreData.GetNexLevelId=GetNexLevelId;
return ExploreData