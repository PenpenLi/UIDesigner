---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by guoyu.
--- DateTime: 2019/6/4 10:06
local NationScienceData = BaseClass("NationScienceData", Singleton)

local TECH_TIMER_PREFIX_NAME = "TECH_TIMER_PREFIX_NAME"-- 科技升级计时器
local TECH_TIMER_LOGIC_OFFSET_MS = 1000 -- 科技升级计时器计时偏移量
--local ScienceData={
--    id=0,--id
--    level=0,--等级
--    lastTime=0,--当前升级时间
--    needTime=0--需要时间
--}
--local ScienceItem=DataClass("ScienceItem",ScienceData)


local function __InitByConfig(self)
    if self.__IsInit then
        return
    end
    self.national_tech = DataUtil.GetData("national_tech")

    --int techPayCost = SNationalGlobals.getIntValueNByKey("TechPayCost");
    self.scienceItems = {}
    self.scienceTables = {}
    self.freeQueueTechIds = {}
    self.payQueueTechIds = {}

    for k, v in pairs(self.national_tech) do
        if v.LvMax == nil then
        else
            local item = {}
            item.id = k
            item.techStaticData = v
            item.level = 0
            item.lastTime = 0
            item.startTime = 0
            table.insert(self.scienceItems, item)
            self.scienceTables[item.id] = item
        end
    end

    table.sort(self.scienceItems, function(a, b)
        return a.id < b.id
    end)
    self.__IsInit = true
end

local function __init(self)
    self.scienceItems = nil
    self.scienceTables = nil

    self.freeQueueTechIds = nil
    self.payQueueTechIds = nil
end

local function __delete(self)
    self:__CleanUpAllTimer()

    self.national_tech = nil
    self.freeQueueTechIds = nil
    self.payQueueTechIds = nil
end

local function __CleanUpAllTimer(self)
    if not self.scienceTables then
        for k, v in pairs(self.scienceTables) do
            LogicTimerManager:GetInstance():RemoveTimer(NationScienceData.TECH_TIMER_PREFIX_NAME .. k)
        end
    end
    self.scienceItems = nil
    self.scienceTables = nil
end

local function ParseByServer(self, data)
    self:__InitByConfig()
    if data == nil or data._is_null then
        Logger.LogErrorVars("没有升级数据~")
        self:__DoServerTimeNil()
        self.freeQueueTechIds = {}
        self.payQueueTechIds = {}
        return
    end
    Logger.Log("服务器传回了科技数据")
    local node = data.node
    if node == nil or node._is_null then
        self:__DoServerTimeNil()
    else
        for k, v in ipairs(node) do
            local item = self:GetScienceItemById(v.id)
            if item ~= nil then
                item.level = math.ceil(v.level)
                item.lastTime = math.ceil(v.lastTime)
                item.startTime = math.ceil(v.startTime)
            else
                Logger.LogErrorVars("科技id ", v.id, "的数据表不存在~")
            end
        end
    end
    self:__ParseServerQueue(data)
    self:StartAllTimerByQueue()
end

local function __DoServerTimeNil(self)
    for k, v in ipairs(self.scienceTables) do
        v.level = 0
        v.lastTime = 0
        v.startTime = 0

        LogicTimerManager:GetInstance():RemoveTimer(NationScienceData.TECH_TIMER_PREFIX_NAME .. k)
    end
end

local function __ParseServerQueue(self, data)
    if data.freeQueue == nil or data.freeQueue._is_null then
        self.freeQueueTechIds = {}
    else

        for i, v in ipairs(data.freeQueue) do
            self.freeQueueTechIds[math.modf(v)] = 1
        end
    end

    if data.payQueue == nil or data.payQueue._is_null then
        self.payQueueTechIds = {}
    else
        for i, v in ipairs(data.payQueue) do
            self.payQueueTechIds[math.modf(v)] = 1
        end
    end
end


-- 立即完成升级更新数据
local function UpdateTechDataByFinish(self, techId, hasEvent)
    local item = self:GetScienceItemById(techId)
    if item ~= nil then
        item.level = item.level + 1
        item.lastTime = 0
        item.startTime = 0
        self:RemoveUpgradeQueueByTechId(techId)
        --Logger.LogErrorVars(" UpdateTechDataByFinish techId : ",techId," free : ",self.freeQueueTechIds," pay : ",self.payQueueTechIds)
        LogicTimerManager:GetInstance():RemoveTimer(NationScienceData.TECH_TIMER_PREFIX_NAME .. techId)
        self:__DoSpcTechLogic(item)
        if hasEvent then
            DataManager:GetInstance():Broadcast(DataMessageNames.ON_NATION_SCIENCE_ONE_FLUSH, techId)
        end
    else
        Logger.LogErrorVars("科技id ", techId, "的数据表不存在~")
    end
end

-- 科技升级数据变动处理
local function __DoSpcTechLogic(self, techData)
    if techData then
        local teamMaxAddCount = 0
        local techStaticData = techData.techStaticData
        if techData.level >= techStaticData.LvMax then
            -- 增加最大值
            local activationEffect = techStaticData.ActivationEffect
            if activationEffect then
                if activationEffect.Type == NationDefine.NATION_TECH_TYPE.TEAM_MAX then
                    teamMaxAddCount = teamMaxAddCount + activationEffect.Value
                end
            end
        end
        local lvEffectDatas = techStaticData.Lv[techData.level]
        if lvEffectDatas ~= nil then
            local effects = lvEffectDatas.Effect
            if effects ~= nil then
                for j, levelEffect in ipairs(effects) do
                    if levelEffect.Type == NationDefine.NATION_TECH_TYPE.TEAM_MAX then
                        teamMaxAddCount = teamMaxAddCount + levelEffect.Value
                    end
                end
            end
        end

        if teamMaxAddCount >= 0 then
            local myTeamIds = nil
            for i = 1, teamMaxAddCount do
                local newTeamId = NationTeamData:GetInstance():AddNewMyTeamData() -- 增加队伍
                if newTeamId > 0 then
                    if myTeamIds == nil then
                        myTeamIds = {}
                    end
                    table.insert(myTeamIds, newTeamId)
                end
            end

            if myTeamIds ~= nil then
                if table.length(myTeamIds) > 0 then
                    DataManager:GetInstance():Broadcast(DataMessageNames.ON_NATION_TEAM_MULTI_TEAM_UPDATE, myTeamIds)
                end
            end
        end
    end
end

local function __ParseServerOneTechData(self, lastTechData, node, hasEvent)
    if node == nil or node._is_null then
        Logger.LogErrorVars("要解析的节点id不存在~")
        return
    end
    local techId = math.modf(node.id)
    local item = self:GetScienceItemById(techId)
    local lastLevel = 0
    if item ~= nil then
        lastLevel = item.level
        item.level = math.modf(node.level)
        item.lastTime = math.modf(node.lastTime)
        item.startTime = math.modf(node.startTime)
        if lastLevel ~= node.level then
            self:__DoSpcTechLogic(item)
        end
    else
        Logger.LogErrorVars("科技id ", techId, "的数据表不存在~")
    end

    if hasEvent then
        DataManager:GetInstance():Broadcast(DataMessageNames.ON_NATION_SCIENCE_ONE_FLUSH, techId)
    end
end


-- 升级更新数据
local function UpdateTechDataByResearch(self, techId, buyType, lastTime, startTime, hasEvent)
    local item = self:GetScienceItemById(techId)
    --Logger.LogErrorVars(" UpdateTechDataByResearch lastTime ：  ",lastTime," startTime : ",startTime)
    if item ~= nil then
        item.lastTime = math.modf(lastTime)
        item.startTime = math.modf(startTime)
        self:AddUpgradeQueueByTechIdAndType(techId, buyType)
        self:StartAllTimerByQueue()
        --if hasEvent then
        --    DataManager:GetInstance():Broadcast(DataMessageNames.ON_NATION_SCIENCE_ONE_FLUSH, techId)
        --end
    else
        Logger.LogErrorVars("科技id ", techId, "的数据表不存在~")
    end
end

-- 取消升级更新数据
local function UpdateTechDataByCancel(self, techId, hasEvent)
    local item = self:GetScienceItemById(techId)
    if item ~= nil then
        item.lastTime = 0
        item.startTime = 0
        self:RemoveUpgradeQueueByTechId(techId)
        --Logger.LogErrorVars(" UpdateTechDataByCancel  ")
        LogicTimerManager:GetInstance():RemoveTimer(NationScienceData.TECH_TIMER_PREFIX_NAME .. techId)
        --if hasEvent then
        --    DataManager:GetInstance():Broadcast(DataMessageNames.ON_NATION_SCIENCE_ONE_FLUSH, techId)
        --end
    else
        Logger.LogErrorVars("科技id ", techId, "的数据表不存在~")
    end
end

local function StartAllTimerByQueue(self)
    local currentTime = TimeSyncManager:GetInstance():GetSimulationJavaMS()
    if self.freeQueueTechIds ~= nil then
        for k, v in pairs(self.freeQueueTechIds) do
            local item = self:GetScienceItemById(k)
            if item ~= nil then
                if item.lastTime > 0 then
                    --item.needTime=math.floor((item.lastTime-TimeSyncManager:GetInstance():GetSimulationJavaMS())/1000)
                    --local function TimerCallBack(self,teamId)
                    --    NationNetManager:GetInstance():SendGetTechsRequest()
                    --end
                    local realTime = TimeSyncManager:GetInstance():GetSimulationJavaMS() > item.lastTime and TimeSyncManager:GetInstance():GetSimulationJavaMS() or item.lastTime
                    LogicTimerManager:GetInstance():AddServerTimer(NationScienceData.TECH_TIMER_PREFIX_NAME .. item.id,
                            LogicTimerManager.LOGIC_TYPE.NONE_CLEAR
                    , SyncTimer.MODE_END_TIME, realTime + NationScienceData.TECH_TIMER_LOGIC_OFFSET_MS, 0, true, self.__UpdateTechLogicTimer, { data = item, superSelf = self })
                    LogicTimerManager:GetInstance():StartTimer(NationScienceData.TECH_TIMER_PREFIX_NAME .. item.id)
                end
            end
        end
    end
    if self.payQueueTechIds ~= nil then
        for k, v in pairs(self.payQueueTechIds) do
            local item = self:GetScienceItemById(k)
            if item ~= nil then
                if item.lastTime > 0 then
                    local realTime = TimeSyncManager:GetInstance():GetSimulationJavaMS() > item.lastTime and TimeSyncManager:GetInstance():GetSimulationJavaMS() or item.lastTime
                    LogicTimerManager:GetInstance():AddServerTimer(NationScienceData.TECH_TIMER_PREFIX_NAME .. item.id,
                            LogicTimerManager.LOGIC_TYPE.NONE_CLEAR
                    , SyncTimer.MODE_END_TIME, realTime + NationScienceData.TECH_TIMER_LOGIC_OFFSET_MS, 0, true, self.__UpdateTechLogicTimer, { data = item, superSelf = self })
                    LogicTimerManager:GetInstance():StartTimer(NationScienceData.TECH_TIMER_PREFIX_NAME .. item.id)
                end
            end
        end
    end
end

local function RemoveAllTimerByQueue(self)
    if self.freeQueueTechIds ~= nil then
        for k, v in pairs(self.freeQueueTechIds) do
            LogicTimerManager:GetInstance():RemoveTimer(NationScienceData.TECH_TIMER_PREFIX_NAME .. k)
        end
    end
    if self.payQueueTechIds ~= nil then
        for k, v in pairs(self.payQueueTechIds) do
            LogicTimerManager:GetInstance():RemoveTimer(NationScienceData.TECH_TIMER_PREFIX_NAME .. k)
        end
    end
end

--  更新科技升级计时器
local function __UpdateTechLogicTimer(selfTimer, obj)
    local item = obj.data
    local superSelf = obj.superSelf
    --Logger.LogErrorVars(" __UpdateTechLogicTimer : ",item)

    -- 需要关闭计时
    NationNetManager:GetInstance():SendSyncTechRequest(item.id, item, Bind(superSelf, superSelf.__OnSyncTechCallback))
end

local function __OnSyncTechCallback(self, opCode, techId, item, netPackages)
    if opCode ~= 0 then
        return
    end
    --Logger.LogErrorVars(" __OnSyncTechCallback : ",techId," pac : ",netPackages)
    self:RemoveAllTimerByQueue() -- 移除所有计时器
    self.freeQueueTechIds = {}
    self.payQueueTechIds = {}
    self:__ParseServerQueue(netPackages)
    self:__ParseServerOneTechData(item, netPackages.node, true)
    self:StartAllTimerByQueue() -- 移除所有计时器
end


--获取科技升级队列免费最大容量
local function GetFreeMaxQueueCount(self)
    return NationMapInfoData:GetInstance():GetNationalGlobal().TechQueue
end


--获取科技升级队列付费最大容量
local function GetPayMaxQueueCount(self)
    return NationMapInfoData:GetInstance():GetNationalGlobal().TechPayQueue
end
--TechPayCost

--获取科技升级队列最大容量
local function GetMaxQueueCount(self)
    return self:GetFreeMaxQueueCount() + self:GetPayMaxQueueCount()
end

--获取科技升级队列免费当前数量
local function GetFreeCurrentQueueCount(self)
    if self.freeQueueTechIds == nil then
        return 0
    end
    return table.count(self.freeQueueTechIds)
end

--获取科技升级队列付费当前数量
local function GetPayCurrentQueueCount(self)
    if self.payQueueTechIds == nil then
        return 0
    end
    return table.count(self.payQueueTechIds)
end

--获取科技升级队列当前数量
local function GetCurrentQueueCount(self)
    return self:GetFreeCurrentQueueCount() + self:GetPayCurrentQueueCount()
end


--获取科技升级队列免费当前数量
local function RemoveUpgradeQueueByTechId(self, techId)
    if self.freeQueueTechIds ~= nil then
        self.freeQueueTechIds[techId] = nil
    end

    if self.payQueueTechIds ~= nil then
        self.payQueueTechIds[techId] = nil
    end
end

-- 添加升级id到升级队列
local function AddUpgradeQueueByTechIdAndType(self, techId, upgradeQueueType)
    if upgradeQueueType == NationDefine.NATION_TECH_UPGRADE_QUEUE_TYPE.FREE then
        self.freeQueueTechIds[techId] = 1
    elseif upgradeQueueType == NationDefine.NATION_TECH_UPGRADE_QUEUE_TYPE.PAY then
        self.payQueueTechIds[techId] = 1
    end
end

local function GetScienceItemById(self, id)
    return self.scienceTables[id]
    --local item=nil
    --for k,v in pairs(self.scienceItems) do
    --    if v.id==id thenD
    --        item=v
    --        break
    --    end
    --end
    --return item
end

local function GetScienceState(self, item)
    local achieveFront = true
    local resourcesEnough = true
    if item.lastTime > TimeSyncManager:GetInstance():GetSimulationJavaMS() then
        return NationDefine.NATION_SCIENCE_ITEM_STATE.NOW_UPGRADEING
    end
    if item.level >= item.techStaticData.LvMax then
        return NationDefine.NATION_SCIENCE_ITEM_STATE.TECH_MAX_LEVEL
    end
    local front = item.techStaticData.Front
    if front ~= nil then
        for k, v in ipairs(front) do
            local frontItem = self:GetScienceItemById(v.Id)
            if frontItem == nil then
                Logger.LogErrorVars(" v.Id : ", v.Id, " not exist vdata is : ", v, " item is : ", item)
                achieveFront = false
            else
                if frontItem.level < v.Lv then
                    achieveFront = false
                    break
                end
            end
        end
    end

    local cost = item.techStaticData.Lv[item.level + 1].Cost
    if cost ~= nil then
        for k, v in ipairs(cost) do
            local resourceItem = NationPlayerData:GetInstance():GetNationResourceRealNumByItemId(v.Id)
            if resourceItem < v.Val then
                resourcesEnough = false
                break
            end
        end
    end
    if achieveFront == false then
        return NationDefine.NATION_SCIENCE_ITEM_STATE.PRE_CONDITION_LOCK
    end
    if achieveFront == true and resourcesEnough == false and item.level == 0 then
        return NationDefine.NATION_SCIENCE_ITEM_STATE.PRE_OK_RES_FAIL_LEVEL_NONE
    end
    if achieveFront == true and resourcesEnough == false and item.level > 0 then
        return NationDefine.NATION_SCIENCE_ITEM_STATE.PRE_OK_RES_FAIL_LEVEL_HAVE
    end
    if achieveFront == true and resourcesEnough == true then
        return NationDefine.NATION_SCIENCE_ITEM_STATE.PRE_OK_RES_OK
    end
end

--获取某一类型资源的所有增加值
local function GetScienceEffectAddByType(self, type)
    local count = 0
    if type == nil then
        return count
    end
    if type == 0 then
        return count
    end
    if self.scienceTables == nil then
        return count
    end
    for k, v in pairs(self.scienceTables) do
        if v.level > 0 then
            if v.level >= v.techStaticData.LvMax then
                -- 增加最大值
                if v.techStaticData.ActivationEffect ~= nil then
                    if v.techStaticData.ActivationEffect.Type == type then
                        count = count + v.techStaticData.ActivationEffect.Value
                    end
                end
            end
            for j, levelEffect in ipairs(v.techStaticData.Lv[v.level].Effect) do
                if levelEffect.Type == type then
                    count = count + levelEffect.Value
                end
            end
        end
    end
    return count
end

--获取开关类型的科技  参考NationDefine.NATION_TECH_TYPE 驻守解锁 TEAM_DEFEND  24 COLLECT_UNLOCK 25 采集解锁
local function GetScienceEffectBoolType(self, type)
    local val = self:GetScienceEffectAddByType(type)
    if val > 0 then
        return true
    end
    return false
end

--判断某个队伍的第三个位置几级解锁
local function GetTeamThirdPosUnlockLevelByTeamId(self, teamId)
    local teachInfo =  self.national_tech[NationDefine.NATION_TECH_ID.FORMATION_UNLOCK]
    for k, v in ipairs(teachInfo.Lv) do
        if v.Effect[1].Value >= teamId then
            return k
        end
    end
    return nil
end

--获取科技静态表
local function GetStaticNationalTechById(self, id)
    return self.national_tech[id]
end

NationScienceData.__init = __init
NationScienceData.__InitByConfig = __InitByConfig
NationScienceData.__CleanUpAllTimer = __CleanUpAllTimer

NationScienceData.ParseByServer = ParseByServer
NationScienceData.GetScienceItemById = GetScienceItemById
NationScienceData.GetScienceState = GetScienceState
NationScienceData.GetScienceEffectAddByType = GetScienceEffectAddByType
NationScienceData.GetScienceEffectBoolType = GetScienceEffectBoolType
NationScienceData.GetTeamThirdPosUnlockLevelByTeamId = GetTeamThirdPosUnlockLevelByTeamId
NationScienceData.GetStaticNationalTechById = GetStaticNationalTechById
NationScienceData.__delete = __delete
NationScienceData.GetFreeMaxQueueCount = GetFreeMaxQueueCount
NationScienceData.GetPayMaxQueueCount = GetPayMaxQueueCount
NationScienceData.GetMaxQueueCount = GetMaxQueueCount
NationScienceData.GetFreeCurrentQueueCount = GetFreeCurrentQueueCount
NationScienceData.GetPayCurrentQueueCount = GetPayCurrentQueueCount
NationScienceData.GetCurrentQueueCount = GetCurrentQueueCount
NationScienceData.RemoveUpgradeQueueByTechId = RemoveUpgradeQueueByTechId
NationScienceData.AddUpgradeQueueByTechIdAndType = AddUpgradeQueueByTechIdAndType
NationScienceData.__DoServerTimeNil = __DoServerTimeNil
NationScienceData.__ParseServerQueue = __ParseServerQueue
NationScienceData.__ParseServerOneTechData = __ParseServerOneTechData
NationScienceData.StartAllTimerByQueue = StartAllTimerByQueue
NationScienceData.RemoveAllTimerByQueue = RemoveAllTimerByQueue
NationScienceData.__UpdateTechLogicTimer = __UpdateTechLogicTimer
NationScienceData.__OnSyncTechCallback = __OnSyncTechCallback
NationScienceData.UpdateTechDataByResearch = UpdateTechDataByResearch
NationScienceData.UpdateTechDataByCancel = UpdateTechDataByCancel
NationScienceData.UpdateTechDataByFinish = UpdateTechDataByFinish
NationScienceData.__DoSpcTechLogic = __DoSpcTechLogic

NationScienceData.TECH_TIMER_PREFIX_NAME = TECH_TIMER_PREFIX_NAME
NationScienceData.TECH_TIMER_LOGIC_OFFSET_MS = TECH_TIMER_LOGIC_OFFSET_MS

return NationScienceData